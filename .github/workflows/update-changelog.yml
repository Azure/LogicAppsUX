name: Update Changelog
run-name: Update Changelog - From ${{ github.event.inputs.old_tag }} to head of ${{ github.event.inputs.target_branch }}
on:
  workflow_dispatch:
    inputs:
      old_tag:
        description: 'Previous version tag (e.g., v5.109.0)'
        required: true
        type: string
      target_branch:
        description: 'Target branch for the PR'
        required: false
        default: 'main'
        type: string

permissions:
  contents: write
  pull-requests: write
  id-token: write

jobs:
  update-changelog:
    runs-on: ubuntu-latest
    steps:
      - name: 'Checkout Repository'
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: 'Set up Node.js'
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: 'Validate Inputs'
        id: validate
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          OLD_TAG="${{ github.event.inputs.old_tag }}"
          TARGET_BRANCH="${{ github.event.inputs.target_branch }}"

          echo "Validating inputs..."
          echo "Old tag: $OLD_TAG"
          echo "Target branch: $TARGET_BRANCH"

          # Check if old tag exists
          if ! git tag -l | grep -q "^${OLD_TAG}$"; then
            echo "Error: Old tag '$OLD_TAG' does not exist"
            exit 1
          fi

          echo "Fetching latest commit for $TARGET_BRANCH..."
          if ! git fetch origin "$TARGET_BRANCH" --depth=1 >/dev/null 2>&1; then
            echo "Error: Unable to fetch target branch '$TARGET_BRANCH'"
            exit 1
          fi

          if ! git rev-parse --verify "origin/$TARGET_BRANCH" >/dev/null 2>&1; then
            echo "Error: Target branch '$TARGET_BRANCH' does not exist on origin"
            exit 1
          fi

          TARGET_COMMIT=$(git rev-parse "origin/$TARGET_BRANCH")
          if [ -z "$TARGET_COMMIT" ]; then
            echo "Error: Unable to resolve latest commit for '$TARGET_BRANCH'"
            exit 1
          fi
          SHORT_TARGET_COMMIT=$(git rev-parse --short "$TARGET_COMMIT")

          echo "Latest commit on $TARGET_BRANCH: $TARGET_COMMIT"
          echo "Inputs validated successfully"

          echo "TARGET_COMMIT=$TARGET_COMMIT" >> $GITHUB_OUTPUT
          echo "SHORT_TARGET_COMMIT=$SHORT_TARGET_COMMIT" >> $GITHUB_OUTPUT

      - name: 'Determine Version'
        id: determine-version
        run: |
          # Get version from old tag and auto-increment patch version
          OLD_TAG="${{ github.event.inputs.old_tag }}"
          # Extract version numbers (remove 'v' prefix)
          VERSION_NUM=${OLD_TAG#v}
          # Increment patch version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION_NUM"
          PATCH=$((PATCH + 1))
          NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
          echo "Auto-incremented version from $OLD_TAG to $NEW_TAG"
          
          echo "Using tag: $NEW_TAG"
          echo "NEW_TAG=$NEW_TAG" >> $GITHUB_OUTPUT

      - name: 'Generate Release Notes'
        id: generate-notes
        uses: actions/github-script@v7
        with:
          script: |
            const newTag = '${{ steps.determine-version.outputs.NEW_TAG }}';
            const oldTag = '${{ github.event.inputs.old_tag }}';
            const targetCommit = '${{ steps.validate.outputs.TARGET_COMMIT }}';
            const targetBranch = '${{ github.event.inputs.target_branch }}';
            const shortTargetCommit = '${{ steps.validate.outputs.SHORT_TARGET_COMMIT }}';
            
            const { execSync } = require('child_process');
            const fs = require('fs');
            
            // Get all commits with PRs using git log
            const gitLog = execSync(
              `git log ${oldTag}..${targetCommit} --oneline --pretty=format:"%s"`,
              { encoding: 'utf-8' }
            ).trim();
            
            const commits = gitLog.split('\n').filter(line => line.trim());
            
            const features = [];
            const bugFixes = [];
            const foundPRs = new Set();
            
            // Process each commit
            for (const commit of commits) {
              // Extract PR number from commit message
              const prMatch = commit.match(/\(#(\d+)\)/);
              if (!prMatch) {
                continue;
              }
              
              const prNumber = prMatch[1];
              if (foundPRs.has(prNumber)) {
                continue;
              }
              foundPRs.add(prNumber);
              
              // Parse conventional commit format: type(scope): description (#PR)
              const conventionalMatch = commit.match(/^([^(]+)\(([^)]+)\):\s*(.+?)\s*\(#\d+\)/);
              
              if (conventionalMatch) {
                const [, commitType, scope, description] = conventionalMatch;
                const formattedLine = `* **${scope.trim()}:** ${description.trim()} ([#${prNumber}](https://github.com/${context.repo.owner}/${context.repo.repo}/pull/${prNumber}))`;
                
                if (commitType.trim().toLowerCase() === 'fix') {
                  bugFixes.push(formattedLine);
                } else {
                  features.push(formattedLine);
                }
              } else {
                // Fallback: just use the commit message as-is
                const cleanMessage = commit.replace(/\s*\(#\d+\)$/, '').trim();
                const formattedLine = `* ${cleanMessage} ([#${prNumber}](https://github.com/${context.repo.owner}/${context.repo.repo}/pull/${prNumber}))`;
                features.push(formattedLine);
              }
            }
            
            // Build formatted output
            const sections = [];
            
            if (features.length > 0) {
              sections.push('### Features\n');
              sections.push(features.join('\n'));
              sections.push('');
            }
            
            if (bugFixes.length > 0) {
              sections.push('### Bug Fixes\n');
              sections.push(bugFixes.join('\n'));
              sections.push('');
            }
            
            const releaseNotes = sections.length > 0 
              ? sections.join('\n').trim()
              : `### Changes\n\nNo changes with PR numbers found.\n\n**Full Changelog**: https://github.com/${context.repo.owner}/${context.repo.repo}/compare/${oldTag}...${targetCommit}`;
            
            // Write to file
            fs.writeFileSync('release-notes.md', releaseNotes);
            
            // Extract version number from tag (remove 'v' prefix if present)
            const versionNumber = newTag.replace(/^v/, '');
            core.setOutput('VERSION_NUMBER', versionNumber);

      - name: 'Create Branch'
        id: create-branch
        run: |
          # Configure Git first
          git config --global user.name "changelog-automation-${{ github.actor }}"
          git config --global user.email "${{ github.actor }}@users.noreply.github.com"
          
          # Create a new branch for the PR from the target commit
          VERSION_NUMBER="${{ steps.generate-notes.outputs.VERSION_NUMBER }}"
          TARGET_BRANCH="${{ github.event.inputs.target_branch }}"
          TARGET_COMMIT="${{ steps.validate.outputs.TARGET_COMMIT }}"
          SHORT_TARGET_COMMIT="${{ steps.validate.outputs.SHORT_TARGET_COMMIT }}"
          BRANCH_NAME="changelog/update-$VERSION_NUMBER-$(date +%s)"

          echo "Creating branch: $BRANCH_NAME from $TARGET_BRANCH ($SHORT_TARGET_COMMIT)"
          git checkout -b "$BRANCH_NAME" "$TARGET_COMMIT"
          
          # Store branch name for next steps
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: 'Update Changelog'
        id: update-changelog
        run: |
          NEW_TAG="${{ steps.determine-version.outputs.NEW_TAG }}"
          OLD_TAG="${{ github.event.inputs.old_tag }}"
          VERSION_NUMBER="${{ steps.generate-notes.outputs.VERSION_NUMBER }}"
          TARGET_BRANCH="${{ github.event.inputs.target_branch }}"
          TARGET_COMMIT="${{ steps.validate.outputs.TARGET_COMMIT }}"
          SHORT_TARGET_COMMIT="${{ steps.validate.outputs.SHORT_TARGET_COMMIT }}"
          
          echo "Updating CHANGELOG.md..."
          
          # Read the generated release notes
          RELEASE_NOTES=$(cat release-notes.md)
          
          # Create the new changelog entry
          NEW_ENTRY="# Logic Apps Designer
          ## [$VERSION_NUMBER](https://github.com/${{ github.repository }}/compare/$OLD_TAG...$TARGET_COMMIT) ($(date '+%Y-%m-%d'))

          _Compared against $TARGET_BRANCH ($SHORT_TARGET_COMMIT)_

          $RELEASE_NOTES

          "
          
          # Check if CHANGELOG.md exists
          if [ ! -f "CHANGELOG.md" ]; then
            echo "Creating new CHANGELOG.md file"
            echo "$NEW_ENTRY" > CHANGELOG.md
          else
            echo "Updating existing CHANGELOG.md file"
            # Create a temporary file with the new entry at the top
            echo "$NEW_ENTRY" > temp_changelog.md
            # Skip the first line of the original changelog (the main title) and append the rest
            tail -n +2 CHANGELOG.md >> temp_changelog.md
            # Replace the original file
            mv temp_changelog.md CHANGELOG.md
          fi
          
          echo "Changelog updated successfully"
          
          # Check if there are changes to commit
          if git diff --quiet CHANGELOG.md; then
            echo "No changes detected in CHANGELOG.md"
            echo "HAS_CHANGES=false" >> $GITHUB_OUTPUT
          else
            echo "Changes detected in CHANGELOG.md"
            echo "HAS_CHANGES=true" >> $GITHUB_OUTPUT
          fi

      - name: 'Commit and Push Changes'
        id: commit-changes
        if: steps.update-changelog.outputs.HAS_CHANGES == 'true'
        run: |
          VERSION_NUMBER="${{ steps.generate-notes.outputs.VERSION_NUMBER }}"
          TARGET_BRANCH="${{ github.event.inputs.target_branch }}"
          SHORT_TARGET_COMMIT="${{ steps.validate.outputs.SHORT_TARGET_COMMIT }}"
          BRANCH_NAME="${{ steps.create-branch.outputs.BRANCH_NAME }}"
          
          # Stage and commit changes
          git add CHANGELOG.md
          git commit -m "docs: update changelog for release ${{ steps.determine-version.outputs.NEW_TAG }}

          - Added release notes for version $VERSION_NUMBER
          - Generated from changes between ${{ github.event.inputs.old_tag }} and $TARGET_BRANCH ($SHORT_TARGET_COMMIT)
          - Auto-generated by changelog workflow"
          
          # Push the new branch
          echo "Pushing branch: $BRANCH_NAME"
          git push origin "$BRANCH_NAME"
          
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: 'Summary'
        if: always()
        run: |
          TARGET_BRANCH="${{ github.event.inputs.target_branch }}"
          SHORT_TARGET_COMMIT="${{ steps.validate.outputs.SHORT_TARGET_COMMIT }}"
          BRANCH_NAME="${{ steps.commit-changes.outputs.BRANCH_NAME }}"

          if [ "${{ steps.update-changelog.outputs.HAS_CHANGES }}" = "true" ]; then
            echo "✅ Changelog updated successfully"
            echo "🌿 Branch created and pushed: $BRANCH_NAME"
            echo ""
            echo "📝 Next Steps:"
            echo "   1. Review the changes in the branch"
            echo "   2. Create a PR manually from: $BRANCH_NAME -> $TARGET_BRANCH"
            echo "   3. Use this URL: https://github.com/${{ github.repository }}/compare/$TARGET_BRANCH...$BRANCH_NAME"
          else
            echo "ℹ️ No changes were needed in the changelog"
          fi
          
          echo ""
          echo "📊 Workflow Summary:"
          echo "- New Version: ${{ steps.determine-version.outputs.NEW_TAG }}"
          echo "- Old Tag: ${{ github.event.inputs.old_tag }}"
          echo "- Target Branch: $TARGET_BRANCH"
          echo "- Target Commit: ${SHORT_TARGET_COMMIT:-N/A}"
          echo "- Changes Made: ${{ steps.update-changelog.outputs.HAS_CHANGES || 'N/A' }}"
