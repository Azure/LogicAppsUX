name: Update Changelog
run-name: Update Changelog - From ${{ github.event.inputs.old_tag }} to head of ${{ github.event.inputs.target_branch }}
on:
  workflow_dispatch:
    inputs:
      old_tag:
        description: 'Previous version tag (e.g., v5.109.0)'
        required: true
        type: string
      target_branch:
        description: 'Target branch for the PR'
        required: false
        default: 'main'
        type: string

permissions:
  contents: write
  pull-requests: write
  id-token: write

jobs:
  update-changelog:
    runs-on: ubuntu-latest
    steps:
      - name: 'Checkout Repository'
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: 'Set up Node.js'
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: 'Validate Inputs'
        id: validate
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          OLD_TAG="${{ github.event.inputs.old_tag }}"
          TARGET_BRANCH="${{ github.event.inputs.target_branch }}"

          echo "Validating inputs..."
          echo "Old tag: $OLD_TAG"
          echo "Target branch: $TARGET_BRANCH"

          # Check if old tag exists
          if ! git tag -l | grep -q "^${OLD_TAG}$"; then
            echo "Error: Old tag '$OLD_TAG' does not exist"
            exit 1
          fi

          echo "Fetching latest commit for $TARGET_BRANCH..."
          if ! git fetch origin "$TARGET_BRANCH" --depth=1 >/dev/null 2>&1; then
            echo "Error: Unable to fetch target branch '$TARGET_BRANCH'"
            exit 1
          fi

          if ! git rev-parse --verify "origin/$TARGET_BRANCH" >/dev/null 2>&1; then
            echo "Error: Target branch '$TARGET_BRANCH' does not exist on origin"
            exit 1
          fi

          TARGET_COMMIT=$(git rev-parse "origin/$TARGET_BRANCH")
          if [ -z "$TARGET_COMMIT" ]; then
            echo "Error: Unable to resolve latest commit for '$TARGET_BRANCH'"
            exit 1
          fi
          SHORT_TARGET_COMMIT=$(git rev-parse --short "$TARGET_COMMIT")

          echo "Latest commit on $TARGET_BRANCH: $TARGET_COMMIT"
          echo "Inputs validated successfully"

          echo "TARGET_COMMIT=$TARGET_COMMIT" >> $GITHUB_OUTPUT
          echo "SHORT_TARGET_COMMIT=$SHORT_TARGET_COMMIT" >> $GITHUB_OUTPUT

      - name: 'Determine Version'
        id: determine-version
        run: |
          # Get version from from old tag
          if [ -z "$NEW_TAG" ]; then
            OLD_TAG="${{ github.event.inputs.old_tag }}"
            # Extract version numbers (remove 'v' prefix)
            VERSION_NUM=${OLD_TAG#v}
            # Increment patch version
            IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION_NUM"
            PATCH=$((PATCH + 1))
            NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
            echo "Auto-incremented version from $OLD_TAG to $NEW_TAG"
          fi
          
          echo "Using tag: $NEW_TAG"
          echo "NEW_TAG=$NEW_TAG" >> $GITHUB_OUTPUT

      - name: 'Generate Release Notes'
        id: generate-notes
        uses: actions/github-script@v7
        with:
          script: |
            const newTag = '${{ steps.determine-version.outputs.NEW_TAG }}';
            const oldTag = '${{ github.event.inputs.old_tag }}';
            const targetCommit = '${{ steps.validate.outputs.TARGET_COMMIT }}';
            const targetBranch = '${{ github.event.inputs.target_branch }}';
            const shortTargetCommit = '${{ steps.validate.outputs.SHORT_TARGET_COMMIT }}';
            
            console.log(`Generating release notes between ${oldTag} and ${targetBranch} (${shortTargetCommit})...`);
            console.log(`Using new tag: ${newTag}`);
            
            let releaseNotes = '';
            
            try {
              // Generate release notes using GitHub API
              const response = await github.rest.repos.generateReleaseNotes({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: newTag,
                target_commitish: targetCommit,
                previous_tag_name: oldTag
              });
              
              console.log('API Response received successfully');
              const rawNotes = response.data.body;
              
              // Parse and format release notes
              const lines = rawNotes.split('\n');
              const features = [];
              const bugFixes = [];
              
              for (const line of lines) {
                const trimmedLine = line.trim();
                
                // Skip empty lines and unwanted headers
                if (!trimmedLine || trimmedLine.startsWith('##') || trimmedLine.startsWith('**Full Changelog')) {
                  continue;
                }
                
                // Process lines that start with *
                if (trimmedLine.startsWith('* ')) {
                  // Match format: * type(scope): description by @author in https://github.com/Azure/LogicAppsUX/pull/1234
                  const fullMatch = trimmedLine.match(/\* ([^(]*)\(([^)]+)\):\s*(.+?) by @\w+ in https:\/\/github\.com\/[^\/]+\/[^\/]+\/pull\/(\d+)/);
                  
                  if (fullMatch) {
                    const [, commitType, scope, description, prNumber] = fullMatch;
                    const formattedLine = `* **${scope.trim()}:** ${description.trim()} ([#${prNumber}](https://github.com/${context.repo.owner}/${context.repo.repo}/pull/${prNumber}))`;
                    
                    if (commitType.trim().toLowerCase() === 'fix') {
                      bugFixes.push(formattedLine);
                    } else {
                      features.push(formattedLine);
                    }
                  } else {
                    // Try simpler format: * description by @author in #1234
                    const altMatch = trimmedLine.match(/\* (.+?) by @\w+ in .*?\/pull\/(\d+)/);
                    
                    if (altMatch) {
                      const [, description, prNumber] = altMatch;
                      
                      // Try to extract scope and type from description
                      const scopeMatch = description.match(/^([^(]*)\(([^)]+)\):\s*(.+)/);
                      
                      if (scopeMatch) {
                        const [, commitType, scope, cleanDescription] = scopeMatch;
                        const formattedLine = `* **${scope}:** ${cleanDescription} ([#${prNumber}](https://github.com/${context.repo.owner}/${context.repo.repo}/pull/${prNumber}))`;
                        
                        if (commitType.trim().toLowerCase() === 'fix') {
                          bugFixes.push(formattedLine);
                        } else {
                          features.push(formattedLine);
                        }
                      } else {
                        // No scope found, use description as-is
                        const formattedLine = `* ${description.trim()} ([#${prNumber}](https://github.com/${context.repo.owner}/${context.repo.repo}/pull/${prNumber}))`;
                        features.push(formattedLine);
                      }
                    }
                  }
                }
              }
              
              // Build formatted output
              const sections = [];
              
              if (features.length > 0) {
                sections.push('### Features\n');
                sections.push(features.join('\n'));
                sections.push('');
              }
              
              if (bugFixes.length > 0) {
                sections.push('### Bug Fixes\n');
                sections.push(bugFixes.join('\n'));
                sections.push('');
              }
              
              releaseNotes = sections.join('\n').trim();
              
            } catch (error) {
              console.log(`Warning: GitHub API call failed: ${error.message}`);
              console.log('Generating custom release notes from git log...');
              
              // Fallback: use git log (this would need to be done in a separate script step)
              // For now, provide a basic message
              releaseNotes = `### Changes

            See the full changelog for details.

            **Full Changelog**: https://github.com/${context.repo.owner}/${context.repo.repo}/compare/${oldTag}...${targetCommit}`;
            }
            
            console.log('Generated release notes:');
            console.log(releaseNotes);
            
            // Write to file
            const fs = require('fs');
            fs.writeFileSync('release-notes.md', releaseNotes);
            
            // Extract version number from tag (remove 'v' prefix if present)
            const versionNumber = newTag.replace(/^v/, '');
            core.setOutput('VERSION_NUMBER', versionNumber);

      - name: 'Create Branch'
        id: create-branch
        run: |
          # Configure Git first
          git config --global user.name "changelog-automation-${{ github.actor }}"
          git config --global user.email "${{ github.actor }}@users.noreply.github.com"
          
          # Create a new branch for the PR from the target commit
          VERSION_NUMBER="${{ steps.generate-notes.outputs.VERSION_NUMBER }}"
          TARGET_BRANCH="${{ github.event.inputs.target_branch }}"
          TARGET_COMMIT="${{ steps.validate.outputs.TARGET_COMMIT }}"
          SHORT_TARGET_COMMIT="${{ steps.validate.outputs.SHORT_TARGET_COMMIT }}"
          BRANCH_NAME="changelog/update-$VERSION_NUMBER-$(date +%s)"

          echo "Creating branch: $BRANCH_NAME from $TARGET_BRANCH ($SHORT_TARGET_COMMIT)"
          git checkout -b "$BRANCH_NAME" "$TARGET_COMMIT"
          
          # Store branch name for next steps
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: 'Update Changelog'
        id: update-changelog
        run: |
          NEW_TAG="${{ steps.determine-version.outputs.NEW_TAG }}"
          OLD_TAG="${{ github.event.inputs.old_tag }}"
          VERSION_NUMBER="${{ steps.generate-notes.outputs.VERSION_NUMBER }}"
          TARGET_BRANCH="${{ github.event.inputs.target_branch }}"
          TARGET_COMMIT="${{ steps.validate.outputs.TARGET_COMMIT }}"
          SHORT_TARGET_COMMIT="${{ steps.validate.outputs.SHORT_TARGET_COMMIT }}"
          
          echo "Updating CHANGELOG.md..."
          
          # Read the generated release notes
          RELEASE_NOTES=$(cat release-notes.md)
          
          # Create the new changelog entry
          NEW_ENTRY="# Logic Apps Designer
          ## [$VERSION_NUMBER](https://github.com/${{ github.repository }}/compare/$OLD_TAG...$TARGET_COMMIT) ($(date '+%Y-%m-%d'))

          _Compared against $TARGET_BRANCH ($SHORT_TARGET_COMMIT)_

          $RELEASE_NOTES

          "
          
          # Check if CHANGELOG.md exists
          if [ ! -f "CHANGELOG.md" ]; then
            echo "Creating new CHANGELOG.md file"
            echo "$NEW_ENTRY" > CHANGELOG.md
          else
            echo "Updating existing CHANGELOG.md file"
            # Create a temporary file with the new entry at the top
            echo "$NEW_ENTRY" > temp_changelog.md
            # Skip the first line of the original changelog (the main title) and append the rest
            tail -n +2 CHANGELOG.md >> temp_changelog.md
            # Replace the original file
            mv temp_changelog.md CHANGELOG.md
          fi
          
          echo "Changelog updated successfully"
          
          # Check if there are changes to commit
          if git diff --quiet CHANGELOG.md; then
            echo "No changes detected in CHANGELOG.md"
            echo "HAS_CHANGES=false" >> $GITHUB_OUTPUT
          else
            echo "Changes detected in CHANGELOG.md"
            echo "HAS_CHANGES=true" >> $GITHUB_OUTPUT
          fi

      - name: 'Commit and Push Changes'
        id: commit-changes
        if: steps.update-changelog.outputs.HAS_CHANGES == 'true'
        run: |
          VERSION_NUMBER="${{ steps.generate-notes.outputs.VERSION_NUMBER }}"
          TARGET_BRANCH="${{ github.event.inputs.target_branch }}"
          SHORT_TARGET_COMMIT="${{ steps.validate.outputs.SHORT_TARGET_COMMIT }}"
          BRANCH_NAME="${{ steps.create-branch.outputs.BRANCH_NAME }}"
          
          # Stage and commit changes
          git add CHANGELOG.md
          git commit -m "docs: update changelog for release ${{ steps.determine-version.outputs.NEW_TAG }}

          - Added release notes for version $VERSION_NUMBER
          - Generated from changes between ${{ github.event.inputs.old_tag }} and $TARGET_BRANCH ($SHORT_TARGET_COMMIT)
          - Auto-generated by changelog workflow"
          
          # Push the new branch
          echo "Pushing branch: $BRANCH_NAME"
          git push origin "$BRANCH_NAME"
          
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: 'Summary'
        if: always()
        run: |
          TARGET_BRANCH="${{ github.event.inputs.target_branch }}"
          SHORT_TARGET_COMMIT="${{ steps.validate.outputs.SHORT_TARGET_COMMIT }}"
          BRANCH_NAME="${{ steps.commit-changes.outputs.BRANCH_NAME }}"

          if [ "${{ steps.update-changelog.outputs.HAS_CHANGES }}" = "true" ]; then
            echo "✅ Changelog updated successfully"
            echo "🌿 Branch created and pushed: $BRANCH_NAME"
            echo ""
            echo "📝 Next Steps:"
            echo "   1. Review the changes in the branch"
            echo "   2. Create a PR manually from: $BRANCH_NAME -> $TARGET_BRANCH"
            echo "   3. Use this URL: https://github.com/${{ github.repository }}/compare/$TARGET_BRANCH...$BRANCH_NAME"
          else
            echo "ℹ️ No changes were needed in the changelog"
          fi
          
          echo ""
          echo "📊 Workflow Summary:"
          echo "- New Version: ${{ steps.determine-version.outputs.NEW_TAG }}"
          echo "- Old Tag: ${{ github.event.inputs.old_tag }}"
          echo "- Target Branch: $TARGET_BRANCH"
          echo "- Target Commit: ${SHORT_TARGET_COMMIT:-N/A}"
          echo "- Changes Made: ${{ steps.update-changelog.outputs.HAS_CHANGES || 'N/A' }}"
