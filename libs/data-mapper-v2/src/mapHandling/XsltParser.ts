import type { MapDefinitionEntry } from '@microsoft/logic-apps-shared';
import { reservedMapDefinitionKeys } from '../constants/MapDefinitionConstants';

/**
 * Set of property names that could cause prototype pollution.
 * These should never be used as object keys from untrusted input.
 */
const DANGEROUS_PROPERTY_NAMES = new Set(['__proto__', 'constructor', 'prototype']);

/**
 * Checks if a property name is safe to use as an object key.
 * Prevents prototype pollution attacks.
 *
 * @param name - The property name to check
 * @returns True if the property name is safe to use
 */
const isSafePropertyName = (name: string): boolean => {
  return !DANGEROUS_PROPERTY_NAMES.has(name);
};

/**
 * Safely assigns a value to an object property, preventing prototype pollution.
 * Uses Object.defineProperty to ensure only own properties are set.
 *
 * @param obj - The object to assign to
 * @param key - The property key
 * @param value - The value to assign
 */
const safeAssign = (obj: MapDefinitionEntry, key: string, value: MapDefinitionEntry | string): void => {
  if (!isSafePropertyName(key)) {
    console.warn(`Skipping potentially dangerous property name: ${key}`);
    return;
  }
  Object.defineProperty(obj, key, {
    value,
    writable: true,
    enumerable: true,
    configurable: true,
  });
};

/**
 * Represents a parsed mapping from an XSLT element.
 */
export interface ParsedMapping {
  /** Target path (from element hierarchy) */
  targetPath: string;
  /** Source XPath expression (from select attribute) */
  sourceExpression: string;
  /** Whether this is inside a loop */
  isInLoop: boolean;
  /** Loop source path if in a loop */
  loopSource?: string;
  /** Whether this is conditional */
  isConditional: boolean;
  /** Condition expression if conditional */
  condition?: string;
}

/**
 * Result of parsing an XSLT document.
 */
export interface XsltParseResult {
  /** Whether parsing was successful */
  success: boolean;
  /** Error message if parsing failed */
  error?: string;
  /** Extracted mappings */
  mappings: ParsedMapping[];
  /** Source schema root element (if identifiable) */
  sourceRoot?: string;
  /** Target schema root element */
  targetRoot?: string;
}

/**
 * Parses XSLT content to extract mapping information.
 * This allows the visual designer to derive mappings from XSLT directly,
 * making XSLT the source of truth rather than embedded metadata.
 *
 * Note: This parser handles the specific XSLT patterns generated by
 * the Data Mapper backend. It may not handle arbitrary hand-written XSLT.
 */
export class XsltParser {
  private xsltContent: string;
  private doc: Document | null = null;

  constructor(xsltContent: string) {
    this.xsltContent = xsltContent;
  }

  /**
   * Parses the XSLT content and extracts mapping information.
   */
  public parse(): XsltParseResult {
    try {
      // Parse XSLT as XML
      this.doc = this.parseXml(this.xsltContent);
      if (!this.doc) {
        return { success: false, error: 'Failed to parse XSLT as XML', mappings: [] };
      }

      // Find the main template
      const templates = this.doc.getElementsByTagNameNS('http://www.w3.org/1999/XSL/Transform', 'template');
      if (templates.length === 0) {
        return { success: false, error: 'No xsl:template found in XSLT', mappings: [] };
      }

      const mappings: ParsedMapping[] = [];
      let targetRoot: string | undefined;

      // Process each template
      for (const template of templates) {
        const match = template.getAttribute('match');
        const mode = template.getAttribute('mode');

        // Process root templates - either match="/" or match="/" with mode="azure.workflow.datamapper"
        // The Data Mapper backend generates templates with mode="azure.workflow.datamapper"
        if (match === '/' && (mode === 'azure.workflow.datamapper' || !mode)) {
          const result = this.processTemplateContent(template, '', false, undefined, false, undefined);
          mappings.push(...result.mappings);
          if (result.targetRoot) {
            targetRoot = result.targetRoot;
          }
        }
      }

      return {
        success: true,
        mappings,
        targetRoot,
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error parsing XSLT';
      return { success: false, error: errorMessage, mappings: [] };
    }
  }

  /**
   * Converts parsed mappings to a MapDefinitionEntry format.
   * This is a simplified conversion - complex XSLT may not convert perfectly.
   */
  public toMapDefinition(parseResult: XsltParseResult, sourceSchemaName: string, targetSchemaName: string): MapDefinitionEntry {
    if (!parseResult.success || parseResult.mappings.length === 0) {
      return {};
    }

    const mapDefinition: MapDefinitionEntry = {
      [reservedMapDefinitionKeys.version]: '1.0',
      [reservedMapDefinitionKeys.sourceSchemaName]: sourceSchemaName,
      [reservedMapDefinitionKeys.targetSchemaName]: targetSchemaName,
    };

    // Group mappings by target path to build the nested structure
    const targetTree: MapDefinitionEntry = {};

    for (const mapping of parseResult.mappings) {
      this.addMappingToTree(targetTree, mapping);
    }

    // Merge target tree into map definition
    Object.assign(mapDefinition, targetTree);

    return mapDefinition;
  }

  /**
   * Parses XML content using DOMParser (browser) or a polyfill.
   */
  private parseXml(xmlContent: string): Document | null {
    // Check if we're in a browser environment with DOMParser
    if (typeof DOMParser !== 'undefined') {
      const parser = new DOMParser();
      const doc = parser.parseFromString(xmlContent, 'application/xml');

      // Check for parse errors
      const parseError = doc.getElementsByTagName('parsererror');
      if (parseError.length > 0) {
        console.error('XML parse error:', parseError[0].textContent);
        return null;
      }

      return doc;
    }

    // For Node.js environment, we'd need a polyfill like xmldom
    // For now, return null and log warning
    console.warn('XsltParser: DOMParser not available in this environment');
    return null;
  }

  /**
   * Processes the content of an xsl:template element.
   */
  private processTemplateContent(
    element: Element,
    currentPath: string,
    isInLoop: boolean,
    loopSource: string | undefined,
    isConditional: boolean,
    condition: string | undefined
  ): { mappings: ParsedMapping[]; targetRoot?: string } {
    const mappings: ParsedMapping[] = [];
    let targetRoot: string | undefined;

    for (const child of Array.from(element.childNodes)) {
      if (child.nodeType === Node.ELEMENT_NODE) {
        const childElement = child as Element;
        const tagName = childElement.localName;
        const namespaceURI = childElement.namespaceURI;

        // Handle XSL elements
        if (namespaceURI === 'http://www.w3.org/1999/XSL/Transform') {
          switch (tagName) {
            case 'value-of': {
              const select = childElement.getAttribute('select');
              if (select && currentPath) {
                mappings.push({
                  targetPath: currentPath,
                  sourceExpression: select,
                  isInLoop,
                  loopSource,
                  isConditional,
                  condition,
                });
              }
              break;
            }
            case 'for-each': {
              const select = childElement.getAttribute('select');
              if (select) {
                const result = this.processTemplateContent(childElement, currentPath, true, select, isConditional, condition);
                mappings.push(...result.mappings);
              }
              break;
            }
            case 'if': {
              const test = childElement.getAttribute('test');
              if (test) {
                const result = this.processTemplateContent(childElement, currentPath, isInLoop, loopSource, true, test);
                mappings.push(...result.mappings);
              }
              break;
            }
            case 'choose':
            case 'when':
            case 'otherwise': {
              // Handle xsl:choose/when/otherwise
              const test = childElement.getAttribute('test');
              const result = this.processTemplateContent(
                childElement,
                currentPath,
                isInLoop,
                loopSource,
                tagName === 'when',
                test || undefined
              );
              mappings.push(...result.mappings);
              break;
            }
            case 'copy-of':
            case 'copy': {
              const select = childElement.getAttribute('select');
              if (select && currentPath) {
                mappings.push({
                  targetPath: currentPath,
                  sourceExpression: select,
                  isInLoop,
                  loopSource,
                  isConditional,
                  condition,
                });
              }
              break;
            }
            case 'element':
            case 'attribute': {
              const name = childElement.getAttribute('name');
              if (name) {
                const newPath = currentPath ? `${currentPath}/${name}` : `/${name}`;
                const result = this.processTemplateContent(childElement, newPath, isInLoop, loopSource, isConditional, condition);
                mappings.push(...result.mappings);
              }
              break;
            }
            default: {
              // Process children for other XSL elements
              const defaultResult = this.processTemplateContent(childElement, currentPath, isInLoop, loopSource, isConditional, condition);
              mappings.push(...defaultResult.mappings);
            }
          }
        } else {
          // This is a literal result element (target element)
          const newPath = currentPath ? `${currentPath}/${tagName}` : `/${tagName}`;

          if (!targetRoot) {
            targetRoot = tagName;
          }

          // Check for attributes that have xsl:value-of or direct mappings
          const result = this.processTemplateContent(childElement, newPath, isInLoop, loopSource, isConditional, condition);
          mappings.push(...result.mappings);

          // Check if this element has direct text content with XPath
          // (This would typically be handled by xsl:value-of inside)
        }
      } else if (child.nodeType === Node.TEXT_NODE) {
        // Text nodes may contain XSLT 3.0 text value templates: {expression}
        const text = child.textContent?.trim();
        if (text && currentPath) {
          // Extract XPath expressions from curly braces (XSLT 3.0 text value templates)
          const ttvMatches = text.match(/\{([^}]+)\}/g);
          if (ttvMatches) {
            for (const match of ttvMatches) {
              // Remove curly braces to get the XPath expression
              let expression = match.slice(1, -1).trim();
              if (expression) {
                // Convert XPath single-quoted string literals to double-quoted format
                // for compatibility with LML deserializer
                // e.g., concat(/a, ' ', /b) -> concat(/a, " ", /b)
                expression = this.convertXPathLiteralsToLmlFormat(expression);

                // Remove namespace prefixes from function calls
                // e.g., math:exp(/a) -> exp(/a)
                expression = this.removeNamespacePrefixes(expression);

                // Convert XPath infix math expressions to function call format
                // e.g., (/Person/age) + (5) -> add(/Person/age, 5)
                expression = this.convertXPathMathToFunctions(expression);

                mappings.push({
                  targetPath: currentPath,
                  sourceExpression: expression,
                  isInLoop,
                  loopSource,
                  isConditional,
                  condition,
                });
              }
            }
          }
        }
      }
    }

    return { mappings, targetRoot };
  }

  /**
   * Converts XPath single-quoted string literals to double-quoted format
   * for compatibility with the LML deserializer.
   * e.g., concat(/a, ' ', /b) -> concat(/a, " ", /b)
   */
  private convertXPathLiteralsToLmlFormat(expression: string): string {
    // Replace single-quoted string literals with double-quoted ones
    // This regex matches single-quoted strings that aren't inside double quotes
    // Pattern: 'content' where content can be anything except single quote
    return expression.replace(/'([^']*)'/g, '"$1"');
  }

  /**
   * Removes namespace prefixes from function calls.
   * e.g., math:exp(/a) -> exp(/a), dm:customFunc(/a) -> customFunc(/a)
   * Common prefixes in Data Mapper XSLT: math, xs, dm, ef
   */
  private removeNamespacePrefixes(expression: string): string {
    // Match namespace:function patterns and remove the namespace prefix
    // Pattern: word followed by colon followed by word and open paren
    // This handles: math:exp(, xs:string(, dm:custom(, etc.
    return expression.replace(/\b([a-zA-Z][\w-]*):([a-zA-Z][\w-]*)\s*\(/g, '$2(');
  }

  /**
   * Converts XPath infix math expressions to function call format.
   * e.g., (/Person/age) + (5) -> add(/Person/age, 5)
   * e.g., (/Person/age) + (6) + (8) -> add(/Person/age, 6, 8) (flat, not nested)
   * Handles: + (add), - (subtract), * (multiply), div (divide)
   */
  private convertXPathMathToFunctions(expression: string): string {
    const trimmed = expression.trim();

    // Map of XPath operators to LML function names
    const operatorMap: { [key: string]: string } = {
      '+': 'add',
      '-': 'subtract',
      '*': 'multiply',
      div: 'divide',
    };

    // Associative operators can have multiple operands flattened
    const associativeOps = ['+', '*'];

    const result = this.parseAndConvertMathExpression(trimmed, operatorMap, associativeOps);
    return result;
  }

  /**
   * Parses a math expression and converts infix operators to function calls.
   * For associative operators (+, *), collects all operands into a flat function call.
   */
  private parseAndConvertMathExpression(expr: string, operatorMap: { [key: string]: string }, associativeOps: string[]): string {
    const trimmed = expr.trim();

    // If the entire expression is wrapped in parentheses, unwrap it
    if (trimmed.startsWith('(') && trimmed.endsWith(')')) {
      const inner = trimmed.slice(1, -1);
      // Check if these are matching outer parentheses
      if (this.isBalancedParens(inner)) {
        // Recursively process the inner expression
        return this.parseAndConvertMathExpression(inner, operatorMap, associativeOps);
      }
    }

    // Find the top-level operator with lowest precedence
    // Process + and - first (lower precedence), then * and div (higher precedence)
    const lowPrecedenceOps = ['+', '-'];
    const highPrecedenceOps = ['*', 'div'];

    // Try low precedence operators first
    for (const op of lowPrecedenceOps) {
      if (associativeOps.includes(op)) {
        // For associative operators, collect all operands
        const operands = this.collectAllOperands(trimmed, op);
        if (operands.length > 1) {
          const convertedOperands = operands.map((operand) => this.parseAndConvertMathExpression(operand, operatorMap, associativeOps));
          return `${operatorMap[op]}(${convertedOperands.join(', ')})`;
        }
      } else {
        // For non-associative operators (like -), use binary split
        const split = this.splitByTopLevelOperator(trimmed, op);
        if (split) {
          const left = this.parseAndConvertMathExpression(split.left, operatorMap, associativeOps);
          const right = this.parseAndConvertMathExpression(split.right, operatorMap, associativeOps);
          return `${operatorMap[op]}(${left}, ${right})`;
        }
      }
    }

    // Then try high precedence operators
    for (const op of highPrecedenceOps) {
      if (associativeOps.includes(op)) {
        // For associative operators, collect all operands
        const operands = this.collectAllOperands(trimmed, op);
        if (operands.length > 1) {
          const convertedOperands = operands.map((operand) => this.parseAndConvertMathExpression(operand, operatorMap, associativeOps));
          return `${operatorMap[op]}(${convertedOperands.join(', ')})`;
        }
      } else {
        // For non-associative operators (like div), use binary split
        const split = this.splitByTopLevelOperator(trimmed, op);
        if (split) {
          const left = this.parseAndConvertMathExpression(split.left, operatorMap, associativeOps);
          const right = this.parseAndConvertMathExpression(split.right, operatorMap, associativeOps);
          return `${operatorMap[op]}(${left}, ${right})`;
        }
      }
    }

    // No operator found, return as-is (it's a value: path, number, or function call)
    return trimmed;
  }

  /**
   * Collects all operands for an associative operator (like + or *).
   * e.g., "a + b + c" -> ["a", "b", "c"]
   */
  private collectAllOperands(expr: string, operator: string): string[] {
    const operands: string[] = [];
    let remaining = expr.trim();

    while (remaining) {
      const split = this.splitByTopLevelOperator(remaining, operator);
      if (split) {
        operands.push(split.left.trim());
        remaining = split.right.trim();
      } else {
        operands.push(remaining);
        break;
      }
    }

    return operands;
  }

  /**
   * Splits an expression by a top-level operator (not inside parentheses or strings).
   */
  private splitByTopLevelOperator(expr: string, operator: string): { left: string; right: string } | null {
    let parenDepth = 0;
    let inString = false;
    let stringChar = '';

    // For 'div', we need to match the word, not just 'd'
    const isWordOperator = operator === 'div';

    for (let i = 0; i < expr.length; i++) {
      const char = expr[i];

      // Track string boundaries
      if ((char === '"' || char === "'") && (i === 0 || expr[i - 1] !== '\\')) {
        if (!inString) {
          inString = true;
          stringChar = char;
        } else if (char === stringChar) {
          inString = false;
        }
        continue;
      }

      if (inString) {
        continue;
      }

      // Track parentheses depth
      if (char === '(') {
        parenDepth++;
        continue;
      }
      if (char === ')') {
        parenDepth--;
        continue;
      }

      // Only match operators at top level (parenDepth === 0)
      if (parenDepth === 0) {
        if (isWordOperator) {
          // Match 'div' as a word (with whitespace around it)
          if (expr.substring(i, i + 3) === 'div') {
            // Check it's surrounded by whitespace or operators
            const before = i > 0 ? expr[i - 1] : ' ';
            const after = i + 3 < expr.length ? expr[i + 3] : ' ';
            if (/\s/.test(before) && /\s/.test(after)) {
              const left = expr.substring(0, i).trim();
              const right = expr.substring(i + 3).trim();
              if (left && right) {
                return { left, right };
              }
            }
          }
        } else if (char === operator) {
          // Match single character operator
          const left = expr.substring(0, i).trim();
          const right = expr.substring(i + 1).trim();

          // For + and -, ensure it's a binary operator, not a unary sign
          // A unary operator would have nothing or an operator before it
          if (operator === '+' || operator === '-') {
            // Skip if there's no left operand (unary at start)
            if (!left) {
              continue;
            }
            // Skip if left ends with an operator (unary after operator)
            if (/[+\-*/(,]$/.test(left)) {
              continue;
            }
          }

          if (left && right) {
            return { left, right };
          }
        }
      }
    }

    return null;
  }

  /**
   * Checks if parentheses are balanced in an expression.
   */
  private isBalancedParens(expr: string): boolean {
    let depth = 0;
    let inString = false;
    let stringChar = '';

    for (let i = 0; i < expr.length; i++) {
      const char = expr[i];

      if ((char === '"' || char === "'") && (i === 0 || expr[i - 1] !== '\\')) {
        if (!inString) {
          inString = true;
          stringChar = char;
        } else if (char === stringChar) {
          inString = false;
        }
        continue;
      }

      if (inString) {
        continue;
      }

      if (char === '(') {
        depth++;
      }
      if (char === ')') {
        depth--;
      }

      // If depth goes negative, the outer parens aren't matching
      if (depth < 0) {
        return false;
      }
    }

    return depth === 0;
  }

  /**
   * Adds a mapping to the target tree structure.
   * Uses safe property assignment to prevent prototype pollution.
   */
  private addMappingToTree(tree: MapDefinitionEntry, mapping: ParsedMapping): void {
    const pathParts = mapping.targetPath.split('/').filter((p) => p);

    let current = tree;

    for (let i = 0; i < pathParts.length; i++) {
      const part = pathParts[i];
      const isLast = i === pathParts.length - 1;

      // Skip dangerous property names
      if (!isSafePropertyName(part)) {
        console.warn(`Skipping mapping with dangerous property name: ${part}`);
        return;
      }

      if (isLast) {
        // Handle loop wrapping
        if (mapping.isInLoop && mapping.loopSource) {
          const loopKey = `$for(${mapping.loopSource})`;
          if (!Object.prototype.hasOwnProperty.call(current, loopKey)) {
            safeAssign(current, loopKey, {});
          }
          safeAssign(current[loopKey] as MapDefinitionEntry, part, mapping.sourceExpression);
        } else if (mapping.isConditional && mapping.condition) {
          const ifKey = `$if(${mapping.condition})`;
          if (!Object.prototype.hasOwnProperty.call(current, ifKey)) {
            safeAssign(current, ifKey, {});
          }
          safeAssign(current[ifKey] as MapDefinitionEntry, part, mapping.sourceExpression);
        } else {
          safeAssign(current, part, mapping.sourceExpression);
        }
      } else {
        if (!Object.prototype.hasOwnProperty.call(current, part)) {
          safeAssign(current, part, {});
        }
        current = current[part] as MapDefinitionEntry;
      }
    }
  }
}

/**
 * Parses XSLT content and returns the parse result.
 * Convenience function for one-off parsing.
 *
 * @param xsltContent - The XSLT content to parse
 * @returns Parse result with mappings
 */
export const parseXslt = (xsltContent: string): XsltParseResult => {
  const parser = new XsltParser(xsltContent);
  return parser.parse();
};

/**
 * Extracts mappings from XSLT and converts to MapDefinitionEntry.
 * This is the main entry point for deriving map definitions from XSLT.
 *
 * @param xsltContent - The XSLT content to parse
 * @param sourceSchemaName - Name of the source schema
 * @param targetSchemaName - Name of the target schema
 * @returns Map definition entry derived from XSLT
 */
export const xsltToMapDefinition = (xsltContent: string, sourceSchemaName: string, targetSchemaName: string): MapDefinitionEntry | null => {
  const parser = new XsltParser(xsltContent);
  const result = parser.parse();

  if (!result.success) {
    console.error('Failed to parse XSLT:', result.error);
    return null;
  }

  return parser.toMapDefinition(result, sourceSchemaName, targetSchemaName);
};
