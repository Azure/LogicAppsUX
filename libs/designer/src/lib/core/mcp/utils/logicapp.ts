import { clone, equals, guid, type Resource, ResourceService, setObjectPropertyValue } from '@microsoft/logic-apps-shared';
import type { LogicAppConfigDetails } from '../../state/mcp/resourceSlice';
import { getAllAppInsights, getAllWorkspaces, getAppInsightsLocations, getRegionMappings } from './queries';

export interface ArmTemplate {
  parameters: Record<string, any>;
  template: {
    $schema: string;
    contentVersion: string;
    parameters: Record<string, any>;
    variables: Record<string, any>;
    resources: ArmTemplateResource[];
  };
}

interface ArmTemplateResource {
  apiVersion: string;
  name: string;
  type: string;
  kind?: string;
  location?: string;
  tags?: Record<string, string>;
  dependsOn?: string[];
  sku?: any;
  identity?: any;
  properties: Record<string, any>;
  resourceGroup?: string;
  subscriptionId?: string;
  resources?: ArmTemplateResource[];
}

interface LogicAppResourceDetails extends LogicAppConfigDetails {
  subscriptionId: string;
  resourceGroup: string;
  location: string;
}

interface WorkspaceInfo {
  isNew: boolean;
  id: string;
  name: string;
  resourceGroupName: string;
}

export const validateAndCreateAppPayload = async (
  details: LogicAppResourceDetails
): Promise<{ isValid: boolean; errorMessage?: string; deploymentName?: string; template?: ArmTemplate }> => {
  const { subscriptionId, resourceGroup, location, appName } = details;
  const domainAvailability = await ResourceService().executeResourceAction(
    `/subscriptions/${subscriptionId}/providers/Microsoft.Web/locations/${location}/checknameavailability`,
    'POST',
    { 'api-version': '2023-12-01' },
    { autoGeneratedDomainNameLabelScope: 'TenantReuse', name: appName, type: 'Site' }
  );
  if (!domainAvailability.nameAvailable) {
    return { isValid: false, errorMessage: domainAvailability.message };
  }

  const armTemplate = await generateArmTemplate(details);
  const depName = `MCP-LogicAppCreate-${guid().substring(0, 8)}`;
  const {
    properties: { provisioningState },
  } = await ResourceService().executeResourceAction(
    `/subscriptions/${subscriptionId}/resourceGroups/${resourceGroup}/providers/Microsoft.Resources/deployments/${depName}/validate`,
    'POST',
    { 'api-version': '2022-12-01' },
    {
      properties: {
        debugSetting: { detailLevel: 'none' },
        mode: 'incremental',
        template: armTemplate.template,
        parameters: armTemplate.parameters,
      },
    }
  );
  return { isValid: equals(provisioningState, 'Succeeded'), deploymentName: depName, template: armTemplate };
};

const generateArmTemplate = async (details: LogicAppResourceDetails): Promise<ArmTemplate> => {
  const template = clone(armTemplate);
  const { subscriptionId, location, appName, appServicePlan, storageAccount, appInsights } = details;

  template.parameters.subscriptionId.value = subscriptionId;
  template.parameters.name.value = appName;
  template.parameters.location.value = location;

  const { resourceGroup: serverFarmResourceGroup, resourceName: hostingPlanName } = parseArmId(appServicePlan.id);
  template.parameters.hostingPlanName.value = hostingPlanName;
  template.parameters.serverFarmResourceGroup.value = serverFarmResourceGroup;

  if (appServicePlan.isNew) {
    const planDetails = getNewAppPlanDetails();
    template.template.resources[0].dependsOn?.push(planDetails.dependsOn as string);
    template.template.resources.push(...(planDetails.resources as ArmTemplateResource[]));
  }

  const { resourceName: storageAccountName } = parseArmId(storageAccount.id);
  template.parameters.storageAccountName.value = storageAccountName;

  if (storageAccount.isNew) {
    const storageDetails = getNewStorageDetails();
    template.template.resources[0].dependsOn?.push(storageDetails.dependsOn as string);
    template.template.resources.push(...(storageDetails.resources as ArmTemplateResource[]));
  }

  if (appInsights?.id) {
    const { resourceName: appInsightsName, subscriptionId, resourceGroup: appInsightsResourceGroup } = parseArmId(appInsights.id);
    const locationData = await _getAppInsightsLocationAndRegion(subscriptionId, location);
    if (locationData) {
      if (appInsights.isNew) {
        const workspaceInfo = await _getWorkspaceResource(subscriptionId, appInsightsResourceGroup, location, locationData.regionCode);

        if (!workspaceInfo) {
          return template;
        }

        const insightsDetails = getNewAppInsightsDetails(appInsightsName, workspaceInfo);
        template.template.resources[0].dependsOn?.push(insightsDetails.dependsOn as string);
        template.template.resources.push(...(insightsDetails.resources as ArmTemplateResource[]));

        if (insightsDetails.mainResource) {
          setObjectPropertyValue(
            template.template.resources[0] as Record<string, any>,
            insightsDetails.mainResource.path,
            insightsDetails.mainResource.value
          );
        }
      } else {
        const appInsightsInfo = await getAppInsight(subscriptionId, appInsights.id);
        const insightsDetails = getAppInsightsDetails(appInsightsInfo?.connectionString as string);
        if (insightsDetails.mainResource) {
          setObjectPropertyValue(
            template.template.resources[0] as Record<string, any>,
            insightsDetails.mainResource.path,
            insightsDetails.mainResource.value
          );
        }
      }
    }
  }

  return template;
};

const getAppInsight = async (subscriptionId: string, resourceId: string): Promise<(Resource & { connectionString: string }) | null> => {
  const allInsights = await getAllAppInsights(subscriptionId);
  return (allInsights.find((insight) => equals(insight.id, resourceId)) as any) || null;
};

const _getAppInsightsLocationAndRegion = async (
  subscriptionId: string,
  location: string
): Promise<{ appInsightsLocation: string; regionCode: string } | null> => {
  const [regionsMap, insightsLocations] = await Promise.all([getRegionMappings(), getAppInsightsLocations(subscriptionId)]);
  const normalizedLocation = getLocationNormalized(location);
  const regionDefinition = regionsMap[normalizedLocation];

  if (!regionDefinition) {
    return null;
  }

  if (insightsLocations.includes(normalizedLocation)) {
    return { appInsightsLocation: normalizedLocation, regionCode: regionDefinition.laRegionCode };
  }

  const regionToCheck = regionDefinition.pairedRegions.find((pairedRegion) => insightsLocations.includes(pairedRegion));
  return regionToCheck && !!regionsMap[regionToCheck].laRegionCode
    ? { appInsightsLocation: regionToCheck, regionCode: regionsMap[regionToCheck].laRegionCode }
    : null;
};

const _getWorkspaceResource = async (
  subscriptionId: string,
  resourceGroupName: string,
  location: string,
  regionCode: string
): Promise<WorkspaceInfo | null> => {
  const allWorkspaces = await getAllWorkspaces(subscriptionId);
  const existingWorkspace = allWorkspaces.find((workspace) => {
    const { resourceGroup, resourceName } = parseArmId(workspace.id);
    return resourceGroup.startsWith('DefaultResourceGroup-') && resourceName.startsWith(`DefaultWorkspace-${subscriptionId}`);
  });

  if (existingWorkspace && (await hasPermission(existingWorkspace.id))) {
    return {
      isNew: false,
      id: existingWorkspace.id,
      name: existingWorkspace.name,
      resourceGroupName: parseArmId(existingWorkspace.id).resourceGroup,
    };
  }

  const defaultRgName = `DefaultResourceGroup-${regionCode}`;
  const name = `DefaultWorkspace-${subscriptionId}-${regionCode}`;
  const resourceId = `/subscriptions/${subscriptionId}/resourceGroups/${defaultRgName}/providers/Microsoft.OperationalInsights/workspaces/${name}`;

  try {
    const resource = await ResourceService().getResource(resourceId, { 'api-version': '2020-08-01' });
    if (resource && (await hasPermission(resourceId))) {
      return { isNew: false, id: resourceId, name, resourceGroupName: defaultRgName };
    }
  } catch {
    /* empty */
  }

  const resourceGroupId = `/subscriptions/${subscriptionId}/resourceGroups/${defaultRgName}`;
  try {
    const resourceGroup = await ResourceService().getResource(resourceGroupId, { 'api-version': '2020-06-01' });
    if (resourceGroup) {
      return { isNew: true, id: resourceId, name, resourceGroupName: defaultRgName };
    }
  } catch (error: any) {
    if (error.response.statusCode === 404 || error.httpStatusCode === 404) {
      try {
        const rgResource = await ResourceService().executeResourceAction(
          resourceGroupId,
          'PUT',
          { 'api-version': '2020-06-01' },
          { location }
        );
        if (rgResource) {
          return { isNew: true, id: resourceId, name, resourceGroupName: defaultRgName };
        }
      } catch {
        /* empty */
      }
    }
  }

  const generatedWorkspaceName = `DefaultWorkspace-${subscriptionId}-${regionCode}-${guid().substring(0, 4)}`;
  const generatedWorkspaceId = `/subscriptions/${subscriptionId}/resourceGroups/${resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/${generatedWorkspaceName}`;
  const workspacesInRG = allWorkspaces.filter((workspace) => equals(workspace.resourceGroup, defaultRgName));
  if (workspacesInRG?.length) {
    if (await hasPermission(workspacesInRG[0].id)) {
      return { isNew: false, id: workspacesInRG[0].id, name: workspacesInRG[0].name, resourceGroupName };
    }

    return {
      isNew: true,
      id: generatedWorkspaceId,
      name: generatedWorkspaceName,
      resourceGroupName,
    };
  }

  if (await hasPermission(`/subscriptions/${subscriptionId}`, 'Microsoft.OperationalInsights/register/action')) {
    return {
      isNew: true,
      id: generatedWorkspaceId,
      name: generatedWorkspaceName,
      resourceGroupName,
    };
  }

  return null;
};

const armTemplate: ArmTemplate = {
  parameters: {
    subscriptionId: {
      value: '',
    },
    name: {
      value: '',
    },
    location: {
      value: '',
    },
    storageAccountName: {
      value: '',
    },
    hostingPlanName: {
      value: '',
    },
    serverFarmResourceGroup: {
      value: '',
    },
    alwaysOn: {
      value: false,
    },
  },
  template: {
    $schema: 'http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#',
    contentVersion: '1.0.0.0',
    parameters: {
      subscriptionId: {
        type: 'string',
      },
      name: {
        type: 'string',
      },
      location: {
        type: 'string',
      },
      storageAccountName: {
        type: 'string',
      },
      hostingPlanName: {
        type: 'string',
      },
      serverFarmResourceGroup: {
        type: 'string',
      },
      alwaysOn: {
        type: 'bool',
      },
    },
    variables: {},
    resources: [
      {
        apiVersion: '2022-03-01',
        name: "[parameters('name')]",
        type: 'Microsoft.Web/sites',
        kind: 'functionapp,workflowapp',
        location: "[parameters('location')]",
        tags: {},
        dependsOn: [],
        properties: {
          name: "[parameters('name')]",
          siteConfig: {
            appSettings: [
              {
                name: 'FUNCTIONS_EXTENSION_VERSION',
                value: '~4',
              },
              {
                name: 'FUNCTIONS_WORKER_RUNTIME',
                value: 'dotnet',
              },
              {
                name: 'WEBSITE_NODE_DEFAULT_VERSION',
                value: '~20',
              },
              {
                name: 'AzureWebJobsStorage',
                value:
                  "[concat('DefaultEndpointsProtocol=https;AccountName=',parameters('storageAccountName'),';AccountKey=',listKeys(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), '2022-05-01').keys[0].value,';EndpointSuffix=','core.windows.net')]",
              },
              {
                name: 'WEBSITE_CONTENTAZUREFILECONNECTIONSTRING',
                value:
                  "[concat('DefaultEndpointsProtocol=https;AccountName=',parameters('storageAccountName'),';AccountKey=',listKeys(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), '2022-05-01').keys[0].value,';EndpointSuffix=','core.windows.net')]",
              },
              {
                name: 'WEBSITE_CONTENTSHARE',
                value: "[concat(toLower(parameters('name')), '9570')]",
              },
              {
                name: 'AzureFunctionsJobHost__extensionBundle__id',
                value: 'Microsoft.Azure.Functions.ExtensionBundle.Workflows',
              },
              {
                name: 'AzureFunctionsJobHost__extensionBundle__version',
                value: '[1.*, 2.0.0)',
              },
              {
                name: 'APP_KIND',
                value: 'workflowApp',
              },
              {
                name: 'FUNCTIONS_INPROC_NET8_ENABLED',
                value: 1,
              },
            ],
            cors: {},
            use32BitWorkerProcess: false,
            ftpsState: 'FtpsOnly',
            netFrameworkVersion: 'v6.0',
          },
          clientAffinityEnabled: false,
          virtualNetworkSubnetId: null,
          functionsRuntimeAdminIsolationEnabled: false,
          publicNetworkAccess: 'Enabled',
          httpsOnly: true,
          serverFarmId:
            "[concat('/subscriptions/', parameters('subscriptionId'),'/resourcegroups/', parameters('serverFarmResourceGroup'), '/providers/Microsoft.Web/serverfarms/', parameters('hostingPlanName'))]",
        },
        resources: [
          {
            type: 'Microsoft.Web/sites/basicPublishingCredentialsPolicies',
            apiVersion: '2022-09-01',
            name: "[concat(parameters('name'), '/scm')]",
            properties: {
              allow: false,
            },
            dependsOn: ["[resourceId('Microsoft.Web/sites', parameters('name'))]"],
          },
          {
            type: 'Microsoft.Web/sites/basicPublishingCredentialsPolicies',
            apiVersion: '2022-09-01',
            name: "[concat(parameters('name'), '/ftp')]",
            properties: {
              allow: false,
            },
            dependsOn: ["[resourceId('Microsoft.Web/sites', parameters('name'))]"],
          },
        ],
        identity: {
          type: 'SystemAssigned',
        },
      },
    ],
  },
};

interface DependentResourceDetails {
  mainResource?: { path: string[]; value: any };
  dependsOn?: string;
  resources?: ArmTemplateResource[];
}

const getNewStorageDetails = (): DependentResourceDetails => ({
  dependsOn: "[concat('Microsoft.Storage/storageAccounts/', parameters('storageAccountName'))]",
  resources: [
    {
      apiVersion: '2022-05-01',
      type: 'Microsoft.Storage/storageAccounts',
      name: "[parameters('storageAccountName')]",
      dependsOn: [],
      location: "[parameters('location')]",
      tags: {},
      kind: 'StorageV2',
      sku: {
        name: 'Standard_LRS',
      },
      properties: {
        supportsHttpsTrafficOnly: true,
        minimumTlsVersion: 'TLS1_2',
        defaultToOAuthAuthentication: true,
        allowBlobPublicAccess: false,
        allowSharedKeyAccess: true,
        publicNetworkAccess: 'Enabled',
      },
    },
  ],
});

const getNewAppPlanDetails = (): DependentResourceDetails => ({
  dependsOn: "[concat('Microsoft.Web/serverfarms/', parameters('hostingPlanName'))]",
  resources: [
    {
      apiVersion: '2018-11-01',
      name: "[parameters('hostingPlanName')]",
      type: 'Microsoft.Web/serverfarms',
      location: "[parameters('location')]",
      kind: '',
      tags: {},
      dependsOn: [],
      properties: {
        name: "[parameters('hostingPlanName')]",
        workerSize: '3',
        workerSizeId: '3',
        numberOfWorkers: '1',
        maximumElasticWorkerCount: '20',
        zoneRedundant: false,
      },
      sku: {
        Tier: 'WorkflowStandard',
        Name: 'WS1',
      },
    },
  ],
});

const getAppInsightsDetails = (connectionString: string): DependentResourceDetails => ({
  mainResource: {
    path: ['properties', 'siteConfig', 'appSettings'],
    value: {
      name: 'APPLICATIONINSIGHTS_CONNECTION_STRING',
      value: connectionString,
    },
  },
});

const getNewAppInsightsDetails = (name: string, workspaceInfo: WorkspaceInfo): DependentResourceDetails => {
  const content: DependentResourceDetails = {
    mainResource: {
      path: ['properties', 'siteConfig', 'appSettings'],
      value: {
        name: 'APPLICATIONINSIGHTS_CONNECTION_STRING',
        value: `[reference('microsoft.insights/components/${name}', '2015-05-01').ConnectionString]`,
      },
    },
    dependsOn: `microsoft.insights/components/${name}`,
    resources: [
      {
        apiVersion: '2020-02-02-preview',
        name: name,
        type: 'microsoft.insights/components',
        location: "[parameters('location')]",
        dependsOn: workspaceInfo.isNew ? ['newWorkspaceTemplate'] : [],
        properties: {
          ApplicationId: "[parameters('name')]",
          Request_Source: 'IbizaWebAppExtensionCreate',
          Flow_Type: 'Redfield',
          Application_Type: 'web',
          WorkspaceResourceId: workspaceInfo.id,
          DisableLocalAuth: false,
        },
      },
    ],
  };

  if (workspaceInfo.isNew) {
    content.resources?.push({
      type: 'Microsoft.Resources/deployments',
      apiVersion: '2021-04-01',
      name: 'newWorkspaceTemplate',
      resourceGroup: workspaceInfo.resourceGroupName,
      subscriptionId: "[parameters('subscriptionId')]",
      properties: {
        mode: 'Incremental',
        template: {
          $schema: 'https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#',
          contentVersion: '1.0.0.0',
          parameters: {},
          variables: {},
          resources: [
            {
              apiVersion: '2020-08-01',
              name: workspaceInfo.name,
              type: 'Microsoft.OperationalInsights/workspaces',
              location: "[parameters('location')]",
              properties: {},
            },
          ],
        },
      },
    });
  }
  return content;
};

const parseArmId = (id: string): { subscriptionId: string; resourceGroup: string; resourceName: string } => {
  const parts = id.split('/');
  return {
    subscriptionId: parts[2],
    resourceGroup: parts[4],
    resourceName: parts[8],
  };
};

const getLocationNormalized = (location: string): string => location.replaceAll(' ', '').toLowerCase();

const hasPermission = async (_resourceId: string, _action?: string): Promise<boolean> => {
  return true;
};

const registeredSubscriptions: Record<string, boolean> = {};
const providers = ['Microsoft.Web', 'Microsoft.Storage', 'Microsoft.Insights', 'Microsoft.OperationalInsights'];

export const areProvidersRegistered = async (subscriptionId: string): Promise<boolean> => {
  if (registeredSubscriptions[subscriptionId]) {
    return true;
  }

  const promises = providers.map(async (provider) => {
    try {
      const result = await ResourceService().getResource(`/subscriptions/${subscriptionId}/providers/${provider}`, {
        'api-version': '2022-09-01',
      });
      return equals((result as any).registrationState, 'registered');
    } catch {
      return false;
    }
  });
  const results = await Promise.all(promises);
  const allRegistered = results.every((result) => result === true);
  if (allRegistered) {
    registeredSubscriptions[subscriptionId] = true;
    return true;
  }

  const providersNotRegistered = results
    .map((value, index) => (value ? null : providers[index]))
    .filter((index) => index !== null) as string[];
  registerAllProviders(subscriptionId, providersNotRegistered);

  return false;
};

const registerAllProviders = (subscriptionId: string, toRegister: string[] = providers): Promise<any>[] => {
  const registerProvider = async (provider: string): Promise<any> =>
    ResourceService().executeResourceAction(`/subscriptions/${subscriptionId}/providers/${provider}`, 'POST', {
      'api-version': '2022-09-01',
    });
  return toRegister.map(registerProvider);
};
