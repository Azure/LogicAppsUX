import {
  clone,
  delay,
  equals,
  getIntl,
  guid,
  LogEntryLevel,
  LoggerService,
  type Resource,
  ResourceService,
} from '@microsoft/logic-apps-shared';
import type { LogicAppConfigDetails } from '../../state/mcp/resourceSlice';
import { getAllAppInsights, getAllWorkspaces, getAppInsightsLocations, getLocationNormalized, getRegionMappings } from './queries';

export interface ArmTemplate {
  parameters: Record<string, any>;
  template: {
    $schema: string;
    contentVersion: string;
    parameters: Record<string, any>;
    variables: Record<string, any>;
    resources: ArmTemplateResource[];
  };
}

interface ArmTemplateResource {
  apiVersion: string;
  name: string;
  type: string;
  kind?: string;
  location?: string;
  tags?: Record<string, string>;
  dependsOn?: string[];
  sku?: any;
  identity?: any;
  properties: Record<string, any>;
  resourceGroup?: string;
  subscriptionId?: string;
  resources?: ArmTemplateResource[];
}

interface LogicAppResourceDetails extends LogicAppConfigDetails {
  subscriptionId: string;
  resourceGroup: string;
  location: string;
}

interface WorkspaceInfo {
  isNew: boolean;
  id: string;
  name: string;
  resourceGroupName: string;
}

export const validateAndCreateAppPayload = async (
  details: LogicAppResourceDetails
): Promise<{ isValid: boolean; errorMessage?: string; deploymentName?: string; template?: ArmTemplate }> => {
  const { subscriptionId, resourceGroup, location, appName } = details;

  registerAllProviders(subscriptionId);

  const domainAvailability = await ResourceService().executeResourceAction(
    `/subscriptions/${subscriptionId}/providers/Microsoft.Web/locations/${location}/checknameavailability`,
    'POST',
    { 'api-version': '2023-12-01' },
    { autoGeneratedDomainNameLabelScope: 'TenantReuse', name: appName, type: 'Site' }
  );
  if (!domainAvailability.nameAvailable) {
    return { isValid: false, errorMessage: domainAvailability.message };
  }

  const armTemplate = await generateArmTemplate(details);
  const depName = `MCP-LogicAppCreate-${guid().substring(0, 8)}`;
  try {
    const {
      properties: { provisioningState },
    } = await ResourceService().executeResourceAction(
      `/subscriptions/${subscriptionId}/resourceGroups/${resourceGroup}/providers/Microsoft.Resources/deployments/${depName}/validate`,
      'POST',
      { 'api-version': '2022-12-01' },
      {
        properties: {
          debugSetting: { detailLevel: 'none' },
          mode: 'incremental',
          template: armTemplate.template,
          parameters: armTemplate.parameters,
        },
      }
    );
    return { isValid: equals(provisioningState, 'Succeeded'), deploymentName: depName, template: armTemplate };
  } catch (ex: any) {
    const errorInfo = extractErrorInfo(ex.error ?? ex);
    const errorMessage = getIntl().formatMessage(
      {
        defaultMessage: 'An error occurred while validating the deployment. Details: {errorDetails}',
        id: '8h1+4D',
        description: 'Error message shown when deployment validation fails',
      },
      { errorDetails: errorInfo ? `Code: ${errorInfo.code}, Message: ${errorInfo.message}` : 'Unknown error' }
    );
    return { isValid: false, errorMessage };
  }
};

export const createLogicAppFromTemplate = async (
  deploymentName: string,
  template: ArmTemplate,
  subscriptionId: string,
  resourceGroup: string
): Promise<string> => {
  let retryAttempts = 0;
  let providersRegistered = await areProvidersRegistered(subscriptionId);

  while (!providersRegistered && retryAttempts < 5) {
    await delay(10 * 1000);
    retryAttempts++;
    providersRegistered = await areProvidersRegistered(subscriptionId);
  }

  try {
    const { id } = await ResourceService().executeResourceAction(
      `/subscriptions/${subscriptionId}/resourceGroups/${resourceGroup}/providers/Microsoft.Resources/deployments/${deploymentName}`,
      'PUT',
      { 'api-version': '2022-12-01' },
      {
        properties: {
          debugSetting: { detailLevel: 'none' },
          mode: 'incremental',
          template: template.template,
          parameters: template.parameters,
          validationLevel: 'Template',
        },
      }
    );
    return id;
  } catch (ex: any) {
    const errorInfo = extractErrorInfo(ex.error ?? ex);
    const intl = getIntl();
    const errorMessage = intl.formatMessage(
      {
        defaultMessage: 'An error occurred while submitting the deployment. Details: {errorDetails}',
        id: '38leUm',
        description: 'Error message shown when deployment submission fails',
      },
      { errorDetails: errorInfo ? `Code: ${errorInfo.code}, Message: ${errorInfo.message}` : 'Unknown error' }
    );

    throw new Error(errorMessage);
  }
};

export const pollForAppCreateCompletion = async (
  deploymentUri: string,
  resourcesToBeCreatedCount: number,
  updateResourceStatuses: (statuses: Record<string, string>) => void
): Promise<{ code: string; message: string } | undefined> => {
  let resourceStatuses: Record<string, string> = {};
  try {
    resourceStatuses = await checkDeploymentCreateOperations(deploymentUri, updateResourceStatuses);
    let retryAttempts = 0;

    while (
      (Object.keys(resourceStatuses).length < resourcesToBeCreatedCount || !isDeploymentCompletedForResources(resourceStatuses)) &&
      retryAttempts < 30
    ) {
      await delay(10 * 1000);
      retryAttempts++;
      resourceStatuses = await checkDeploymentCreateOperations(deploymentUri, updateResourceStatuses);
    }

    const response = await pollForDeploymentStatus(deploymentUri);
    return response;
  } catch (ex: any) {
    for (const key of Object.keys(resourceStatuses)) {
      if (equals(resourceStatuses[key], 'running')) {
        resourceStatuses[key] = 'creating';
      }
    }

    const errorInfo = extractErrorInfo(ex.error ?? ex);
    const intl = getIntl();
    return errorInfo
      ? errorInfo
      : {
          code: 'DeploymentFailed',
          message: intl.formatMessage({
            defaultMessage: 'An error occurred while creating the app. Unknown error.',
            id: 'k8fofe',
            description: 'Error message shown when app creation fails',
          }),
        };
  }
};

const checkDeploymentCreateOperations = async (
  deploymentUri: string,
  updateResourceStatuses: (statuses: Record<string, string>) => void
): Promise<Record<string, string>> => {
  const response: any = await ResourceService().getResource(`${deploymentUri}/operations`, { 'api-version': '2022-12-01' });

  const result = (response.value || [])
    .filter((operation: any) => equals(operation.properties.provisioningOperation, 'Create'))
    .reduce((result: Record<string, string>, operation: any) => {
      const resourceType = operation.properties.targetResource?.resourceType;
      const uiResourceType = getUIResourceType(resourceType);
      if (uiResourceType) {
        result[uiResourceType] = operation.properties.provisioningState?.toLowerCase();
      }
      return result;
    }, {});

  if ((response.value ?? []).length > 0) {
    updateResourceStatuses(result);
  }

  return result;
};

const pollForDeploymentStatus = async (deploymentUri: string): Promise<{ code: string; message: string } | undefined> => {
  const maxRetries = 6;
  const retryIntervalInSeconds = 10;
  let retryAttempts = 0;
  let response = await checkDeploymentStatus(deploymentUri);

  while (!isDeploymentCompleted(response.properties.provisioningState) && retryAttempts < maxRetries) {
    await delay(retryIntervalInSeconds * 1000);
    retryAttempts++;
    response = await checkDeploymentStatus(deploymentUri);
  }

  const { properties } = response;
  const intl = getIntl();
  if (equals(properties.provisioningState, 'Running')) {
    return {
      code: 'DeploymentTimeout',
      message: intl.formatMessage({
        defaultMessage: 'The deployment is taking longer than expected. Please check the Azure portal for more details.',
        id: '80T6Ut',
        description: 'Error message shown when deployment times out',
      }),
    };
  }

  return equals(properties.provisioningState, 'Failed')
    ? (extractErrorInfo(properties.error) ?? {
        code: 'DeploymentFailed',
        message: intl.formatMessage({
          defaultMessage: 'The deployment failed with unknown reason. Please check the Azure portal for more details.',
          id: 'ammu2x',
          description: 'Error message shown when deployment fails',
        }),
      })
    : undefined;
};

const registeredSubscriptions: Record<string, boolean> = {};
const providers = ['Microsoft.Web', 'Microsoft.Storage', 'Microsoft.Insights', 'Microsoft.OperationalInsights'];

export const areProvidersRegistered = async (subscriptionId: string): Promise<boolean> => {
  if (registeredSubscriptions[subscriptionId]) {
    return true;
  }

  const promises = providers.map(async (provider) => {
    try {
      const result = await ResourceService().getResource(`/subscriptions/${subscriptionId}/providers/${provider}`, {
        'api-version': '2022-09-01',
      });
      return equals((result as any).registrationState, 'registered');
    } catch {
      return false;
    }
  });
  const results = await Promise.all(promises);
  const allRegistered = results.every((result) => result === true);
  if (allRegistered) {
    registeredSubscriptions[subscriptionId] = true;
    return true;
  }

  const providersNotRegistered = results
    .map((value, index) => (value ? null : providers[index]))
    .filter((index) => index !== null) as string[];
  registerAllProviders(subscriptionId, providersNotRegistered);

  return false;
};

const registerAllProviders = (subscriptionId: string, toRegister: string[] = providers): Promise<any>[] => {
  const registerProvider = async (provider: string): Promise<any> =>
    ResourceService().executeResourceAction(`/subscriptions/${subscriptionId}/providers/${provider}/register`, 'POST', {
      'api-version': '2021-04-01',
    });
  return toRegister.map(registerProvider);
};

const getUIResourceType = (resourceType: string): string | undefined => {
  switch (resourceType.toLowerCase()) {
    case 'microsoft.web/sites':
      return 'logicapp';
    case 'microsoft.storage/storageaccounts':
      return 'storageaccount';
    case 'microsoft.web/serverfarms':
      return 'appserviceplan';
    case 'microsoft.insights/components':
      return 'appinsights';
    default:
      return undefined;
  }
};

const checkDeploymentStatus = async (deploymentUri: string): Promise<any> => {
  try {
    return ResourceService().getResource(deploymentUri, { 'api-version': '2022-12-01' });
  } catch (error: any) {
    LoggerService().log({
      level: LogEntryLevel.Warning,
      area: 'MCP.LogicAppCreate.PollDeployment',
      message: `Failed to fetch deployment status from ${deploymentUri}. Error: ${error.message || error}`,
    });
  }
};

const isDeploymentCompleted = (provisioningState: string): boolean =>
  equals(provisioningState, 'failed') || equals(provisioningState, 'succeeded');

const isDeploymentCompletedForResources = (resources: Record<string, string>): boolean =>
  Object.keys(resources).some((resource) => equals(resources[resource], 'failed')) ||
  Object.keys(resources).every((resource) => equals(resources[resource], 'succeeded'));

const extractErrorInfo = (error: any): { message: string; code: string } | undefined => {
  const hasDetails = (errorInfo: any) => errorInfo?.details && Array.isArray(errorInfo.details);
  let errorInfo = error;

  while (hasDetails(errorInfo)) {
    errorInfo = errorInfo.details[0];
  }

  if (errorInfo?.message) {
    return { message: errorInfo.message, code: errorInfo.code };
  }

  return undefined;
};

const generateArmTemplate = async (details: LogicAppResourceDetails): Promise<ArmTemplate> => {
  const template = clone(armTemplate);
  const { subscriptionId, location, appName, appServicePlan, storageAccount, appInsights } = details;

  template.parameters.subscriptionId.value = subscriptionId;
  template.parameters.name.value = appName;
  template.parameters.location.value = location;

  const { resourceGroup: serverFarmResourceGroup, resourceName: hostingPlanName } = parseArmId(appServicePlan.id);
  template.parameters.hostingPlanName.value = hostingPlanName;
  template.parameters.serverFarmResourceGroup.value = serverFarmResourceGroup;

  if (appServicePlan.isNew) {
    const planDetails = getNewAppPlanDetails();
    template.template.resources[0].dependsOn?.push(planDetails.dependsOn as string);
    template.template.resources.push(...(planDetails.resources as ArmTemplateResource[]));
  }

  const { resourceName: storageAccountName } = parseArmId(storageAccount.id);
  template.parameters.storageAccountName.value = storageAccountName;

  const storageDetails = getStorageDetails(storageAccount.id, !!storageAccount.isNew);
  template.template.resources[0].properties.siteConfig.appSettings.push(...(storageDetails.appSettings as { name: string; value: any }[]));

  if (storageAccount.isNew) {
    template.template.resources[0].dependsOn?.push(storageDetails.dependsOn as string);
    template.template.resources.push(...(storageDetails.resources as ArmTemplateResource[]));
  }

  if (appInsights?.id) {
    const { resourceName: appInsightsName, subscriptionId, resourceGroup: appInsightsResourceGroup } = parseArmId(appInsights.id);
    const locationData = await _getAppInsightsLocationAndRegion(subscriptionId, location);
    if (locationData) {
      if (appInsights.isNew) {
        const workspaceInfo = await _getWorkspaceResource(subscriptionId, appInsightsResourceGroup, location, locationData.regionCode);

        if (!workspaceInfo) {
          return template;
        }

        const insightsDetails = getNewAppInsightsDetails(appInsightsName, workspaceInfo);
        template.template.resources[0].properties.siteConfig.appSettings.push(
          ...(insightsDetails.appSettings as { name: string; value: any }[])
        );
        template.template.resources[0].dependsOn?.push(insightsDetails.dependsOn as string);
        template.template.resources.push(...(insightsDetails.resources as ArmTemplateResource[]));
      } else {
        const appInsightsInfo = await getAppInsight(subscriptionId, appInsights.id);
        const insightsDetails = getAppInsightsDetails(appInsightsInfo?.connectionString as string);
        template.template.resources[0].properties.siteConfig.appSettings.push(
          ...(insightsDetails.appSettings as { name: string; value: any }[])
        );
      }
    }
  }

  return template;
};

const getAppInsight = async (subscriptionId: string, resourceId: string): Promise<(Resource & { connectionString: string }) | null> => {
  const allInsights = await getAllAppInsights(subscriptionId);
  return (allInsights.find((insight) => equals(insight.id, resourceId)) as any) || null;
};

const _getAppInsightsLocationAndRegion = async (
  subscriptionId: string,
  location: string
): Promise<{ appInsightsLocation: string; regionCode: string } | null> => {
  const [regionsMap, insightsLocations] = await Promise.all([getRegionMappings(), getAppInsightsLocations(subscriptionId)]);
  const normalizedLocation = getLocationNormalized(location);
  const regionDefinition = regionsMap[normalizedLocation];

  if (!regionDefinition) {
    return null;
  }

  if (insightsLocations.includes(normalizedLocation)) {
    return { appInsightsLocation: normalizedLocation, regionCode: regionDefinition.laRegionCode };
  }

  const regionToCheck = regionDefinition.pairedRegions.find((pairedRegion) => insightsLocations.includes(pairedRegion));
  return regionToCheck && !!regionsMap[regionToCheck].laRegionCode
    ? { appInsightsLocation: regionToCheck, regionCode: regionsMap[regionToCheck].laRegionCode }
    : null;
};

const _getWorkspaceResource = async (
  subscriptionId: string,
  resourceGroupName: string,
  location: string,
  regionCode: string
): Promise<WorkspaceInfo | null> => {
  const allWorkspaces = await getAllWorkspaces(subscriptionId);
  const existingWorkspace = allWorkspaces.find((workspace) => {
    const { resourceGroup, resourceName } = parseArmId(workspace.id);
    return resourceGroup.startsWith('DefaultResourceGroup-') && resourceName.startsWith(`DefaultWorkspace-${subscriptionId}`);
  });

  if (existingWorkspace && (await hasPermission(existingWorkspace.id))) {
    return {
      isNew: false,
      id: existingWorkspace.id,
      name: existingWorkspace.name,
      resourceGroupName: parseArmId(existingWorkspace.id).resourceGroup,
    };
  }

  const defaultRgName = `DefaultResourceGroup-${regionCode}`;
  const name = `DefaultWorkspace-${subscriptionId}-${regionCode}`;
  const resourceId = `/subscriptions/${subscriptionId}/resourceGroups/${defaultRgName}/providers/Microsoft.OperationalInsights/workspaces/${name}`;

  try {
    const resource = await ResourceService().getResource(resourceId, { 'api-version': '2020-08-01' });
    if (resource && (await hasPermission(resourceId))) {
      return { isNew: false, id: resourceId, name, resourceGroupName: defaultRgName };
    }
  } catch {
    /* empty */
  }

  const resourceGroupId = `/subscriptions/${subscriptionId}/resourceGroups/${defaultRgName}`;
  try {
    const resourceGroup = await ResourceService().getResource(resourceGroupId, { 'api-version': '2020-06-01' });
    if (resourceGroup) {
      return { isNew: true, id: resourceId, name, resourceGroupName: defaultRgName };
    }
  } catch (error: any) {
    if (error.response?.statusCode === 404 || error.httpStatusCode === 404) {
      try {
        const rgResource = await ResourceService().executeResourceAction(
          resourceGroupId,
          'PUT',
          { 'api-version': '2020-06-01' },
          { location }
        );
        if (rgResource) {
          return { isNew: true, id: resourceId, name, resourceGroupName: defaultRgName };
        }
      } catch {
        /* empty */
      }
    }
  }

  const generatedWorkspaceName = `DefaultWorkspace-${subscriptionId}-${regionCode}-${guid().substring(0, 4)}`;
  const generatedWorkspaceId = `/subscriptions/${subscriptionId}/resourceGroups/${resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/${generatedWorkspaceName}`;
  const workspacesInRG = allWorkspaces.filter((workspace) => equals(workspace.resourceGroup, defaultRgName));
  if (workspacesInRG?.length) {
    if (await hasPermission(workspacesInRG[0].id)) {
      return { isNew: false, id: workspacesInRG[0].id, name: workspacesInRG[0].name, resourceGroupName };
    }

    return {
      isNew: true,
      id: generatedWorkspaceId,
      name: generatedWorkspaceName,
      resourceGroupName,
    };
  }

  if (await hasPermission(`/subscriptions/${subscriptionId}`, 'Microsoft.OperationalInsights/register/action')) {
    return {
      isNew: true,
      id: generatedWorkspaceId,
      name: generatedWorkspaceName,
      resourceGroupName,
    };
  }

  return null;
};

const armTemplate: ArmTemplate = {
  parameters: {
    subscriptionId: {
      value: '',
    },
    name: {
      value: '',
    },
    location: {
      value: '',
    },
    storageAccountName: {
      value: '',
    },
    hostingPlanName: {
      value: '',
    },
    serverFarmResourceGroup: {
      value: '',
    },
    alwaysOn: {
      value: false,
    },
  },
  template: {
    $schema: 'http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#',
    contentVersion: '1.0.0.0',
    parameters: {
      subscriptionId: {
        type: 'string',
      },
      name: {
        type: 'string',
      },
      location: {
        type: 'string',
      },
      storageAccountName: {
        type: 'string',
      },
      hostingPlanName: {
        type: 'string',
      },
      serverFarmResourceGroup: {
        type: 'string',
      },
      alwaysOn: {
        type: 'bool',
      },
    },
    variables: {},
    resources: [
      {
        apiVersion: '2022-03-01',
        name: "[parameters('name')]",
        type: 'Microsoft.Web/sites',
        kind: 'functionapp,workflowapp',
        location: "[parameters('location')]",
        tags: {},
        dependsOn: [],
        properties: {
          name: "[parameters('name')]",
          siteConfig: {
            appSettings: [
              {
                name: 'FUNCTIONS_EXTENSION_VERSION',
                value: '~4',
              },
              {
                name: 'FUNCTIONS_WORKER_RUNTIME',
                value: 'dotnet',
              },
              {
                name: 'WEBSITE_NODE_DEFAULT_VERSION',
                value: '~20',
              },
              {
                name: 'WEBSITE_CONTENTSHARE',
                value: "[concat(toLower(parameters('name')), '9570')]",
              },
              {
                name: 'AzureFunctionsJobHost__extensionBundle__id',
                value: 'Microsoft.Azure.Functions.ExtensionBundle.Workflows',
              },
              {
                name: 'AzureFunctionsJobHost__extensionBundle__version',
                value: '[1.*, 2.0.0)',
              },
              {
                name: 'APP_KIND',
                value: 'workflowApp',
              },
              {
                name: 'FUNCTIONS_INPROC_NET8_ENABLED',
                value: 1,
              },
            ],
            cors: {},
            use32BitWorkerProcess: false,
            ftpsState: 'FtpsOnly',
            netFrameworkVersion: 'v6.0',
          },
          clientAffinityEnabled: false,
          virtualNetworkSubnetId: null,
          functionsRuntimeAdminIsolationEnabled: false,
          publicNetworkAccess: 'Enabled',
          httpsOnly: true,
          serverFarmId:
            "[concat('/subscriptions/', parameters('subscriptionId'),'/resourcegroups/', parameters('serverFarmResourceGroup'), '/providers/Microsoft.Web/serverfarms/', parameters('hostingPlanName'))]",
        },
        resources: [
          {
            type: 'Microsoft.Web/sites/basicPublishingCredentialsPolicies',
            apiVersion: '2022-09-01',
            name: "[concat(parameters('name'), '/scm')]",
            properties: {
              allow: false,
            },
            dependsOn: ["[resourceId('Microsoft.Web/sites', parameters('name'))]"],
          },
          {
            type: 'Microsoft.Web/sites/basicPublishingCredentialsPolicies',
            apiVersion: '2022-09-01',
            name: "[concat(parameters('name'), '/ftp')]",
            properties: {
              allow: false,
            },
            dependsOn: ["[resourceId('Microsoft.Web/sites', parameters('name'))]"],
          },
        ],
        identity: {
          type: 'SystemAssigned',
        },
      },
    ],
  },
};

interface DependentResourceDetails {
  appSettings?: { name: string; value: any }[];
  dependsOn?: string;
  resources?: ArmTemplateResource[];
}

const getStorageDetails = (resourceId: string, isNew: boolean): DependentResourceDetails => {
  const { subscriptionId, resourceGroup } = parseArmId(resourceId);

  const storageConnectionString = `[concat('DefaultEndpointsProtocol=https;AccountName=',parameters('storageAccountName'),';AccountKey=',listKeys(resourceId('${subscriptionId}','${resourceGroup}','Microsoft.Storage/storageAccounts', parameters('storageAccountName')), '2022-05-01').keys[0].value,';EndpointSuffix=','core.windows.net')]`;
  const appSettings = [
    {
      name: 'AzureWebJobsStorage',
      value: storageConnectionString,
    },
    {
      name: 'WEBSITE_CONTENTAZUREFILECONNECTIONSTRING',
      value: storageConnectionString,
    },
  ];

  const result = { appSettings };
  return isNew
    ? {
        ...result,
        dependsOn: "[concat('Microsoft.Storage/storageAccounts/', parameters('storageAccountName'))]",
        resources: [
          {
            apiVersion: '2022-05-01',
            type: 'Microsoft.Storage/storageAccounts',
            name: "[parameters('storageAccountName')]",
            dependsOn: [],
            location: "[parameters('location')]",
            tags: {},
            kind: 'StorageV2',
            sku: {
              name: 'Standard_LRS',
            },
            properties: {
              supportsHttpsTrafficOnly: true,
              minimumTlsVersion: 'TLS1_2',
              defaultToOAuthAuthentication: true,
              allowBlobPublicAccess: false,
              allowSharedKeyAccess: true,
              publicNetworkAccess: 'Enabled',
            },
          },
        ],
      }
    : result;
};

const getNewAppPlanDetails = (): DependentResourceDetails => ({
  dependsOn: "[concat('Microsoft.Web/serverfarms/', parameters('hostingPlanName'))]",
  resources: [
    {
      apiVersion: '2018-11-01',
      name: "[parameters('hostingPlanName')]",
      type: 'Microsoft.Web/serverfarms',
      location: "[parameters('location')]",
      kind: '',
      tags: {},
      dependsOn: [],
      properties: {
        name: "[parameters('hostingPlanName')]",
        workerSize: '3',
        workerSizeId: '3',
        numberOfWorkers: '1',
        maximumElasticWorkerCount: '20',
        zoneRedundant: false,
      },
      sku: {
        Tier: 'WorkflowStandard',
        Name: 'WS1',
      },
    },
  ],
});

const getAppInsightsDetails = (connectionString: string): DependentResourceDetails => ({
  appSettings: [
    {
      name: 'APPLICATIONINSIGHTS_CONNECTION_STRING',
      value: connectionString,
    },
  ],
});

const getNewAppInsightsDetails = (name: string, workspaceInfo: WorkspaceInfo): DependentResourceDetails => {
  const content: DependentResourceDetails = {
    appSettings: [
      {
        name: 'APPLICATIONINSIGHTS_CONNECTION_STRING',
        value: `[reference('microsoft.insights/components/${name}', '2020-02-02').ConnectionString]`,
      },
    ],
    dependsOn: `microsoft.insights/components/${name}`,
    resources: [
      {
        apiVersion: '2020-02-02-preview',
        name: name,
        type: 'microsoft.insights/components',
        location: "[parameters('location')]",
        dependsOn: workspaceInfo.isNew ? ['newWorkspaceTemplate'] : [],
        properties: {
          ApplicationId: "[parameters('name')]",
          Request_Source: 'IbizaWebAppExtensionCreate',
          Flow_Type: 'Redfield',
          Application_Type: 'web',
          WorkspaceResourceId: workspaceInfo.id,
          DisableLocalAuth: false,
        },
      },
    ],
  };

  if (workspaceInfo.isNew) {
    content.resources?.push({
      type: 'Microsoft.Resources/deployments',
      apiVersion: '2021-04-01',
      name: 'newWorkspaceTemplate',
      resourceGroup: workspaceInfo.resourceGroupName,
      subscriptionId: "[parameters('subscriptionId')]",
      properties: {
        mode: 'Incremental',
        template: {
          $schema: 'https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#',
          contentVersion: '1.0.0.0',
          parameters: {},
          variables: {},
          resources: [
            {
              apiVersion: '2020-08-01',
              name: workspaceInfo.name,
              type: 'Microsoft.OperationalInsights/workspaces',
              location: "[parameters('location')]",
              properties: {},
            },
          ],
        },
      },
    });
  }
  return content;
};

const parseArmId = (id: string): { subscriptionId: string; resourceGroup: string; resourceName: string } => {
  const parts = id.split('/');
  return {
    subscriptionId: parts[2],
    resourceGroup: parts[4],
    resourceName: parts[8],
  };
};

const hasPermission = async (_resourceId: string, _action?: string): Promise<boolean> => {
  return true;
};
