import { equals, type LogicAppsV2, optional } from '@microsoft/logic-apps-shared';
import type { RootState } from '../../state/mcp/store';
import { parameterValueToString } from '../../utils/parameters/helper';
import type { Settings } from '../../actions/bjsworkflow/settings';
import type { NodeOperation, NodeInputs } from '../../state/operation/operationMetadataSlice';
import {
  getRetryPolicy,
  type SerializedParameter,
  serializeParametersFromSwagger,
  serializeSettings,
} from '../../actions/bjsworkflow/serializer';
import { getOperationInputParameters } from '../../state/operation/operationSelector';
import Constants from '../../../common/constants';
import type { NodeStaticResults } from '../../actions/bjsworkflow/staticresults';

export const serializeMcpWorkflows = async (state: RootState): Promise<Record<string, LogicAppsV2.WorkflowDefinition>> => {
  const {
    connection: { connectionsMapping },
    operation: { operationInfo, inputParameters, settings },
  } = state;
  const workflows: Record<string, LogicAppsV2.WorkflowDefinition> = {};
  const promises = Object.keys(operationInfo).map(async (nodeId) => {
    const referenceName = connectionsMapping[nodeId] as string;
    return getOperationDefinitionAndTriggerInputs(referenceName, operationInfo[nodeId], inputParameters[nodeId], settings[nodeId] ?? {});
  });

  const allOperations = await Promise.all(promises);

  for (const operationData of allOperations) {
    const { operationId, definition: operationDefinition, triggerInputs } = operationData;
    const definition = generateDefinition(operationId, operationDefinition, triggerInputs);
    workflows[operationId] = definition;
  }

  return workflows;
};

const getOperationDefinitionAndTriggerInputs = async (
  referenceName: string,
  operationInfo: NodeOperation,
  nodeInputs: NodeInputs,
  nodeSettings: Settings
): Promise<{ operationId: string; definition: LogicAppsV2.OperationDefinition; triggerInputs: SerializedParameter[] }> => {
  const { operationId, type, kind } = operationInfo;
  const allInputs: SerializedParameter[] = getOperationInputParameters(nodeInputs).map((input) => ({
    ...input,
    value: parameterValueToString(input, true /* isDefinitionValue */),
  }));
  const triggerInputs: SerializedParameter[] = [];
  const inputsToSerialize = allInputs.map((input) => {
    if (input.required) {
      if (!input.value) {
        input.value = getTriggerInputExpression(input);
        triggerInputs.push(input);
      }
    } else if (input.visibility === 'important' && !input.conditionalVisibility) {
      if (!input.value) {
        input.value = getTriggerInputExpression(input);
        triggerInputs.push(input);
      }
    }

    return input;
  });

  const inputPathValue = await serializeParametersFromSwagger(inputsToSerialize, operationInfo);

  return {
    operationId,
    definition: {
      type: equals(type, Constants.NODE.TYPE.API_CONNECTION) ? Constants.SERIALIZED_TYPE.API_CONNECTION : type,
      ...optional('kind', kind),
      inputs: { host: { connection: { referenceName } }, ...inputPathValue, retryPolicy: getRetryPolicy(nodeSettings) },
      ...optional('runAfter', {}),
      ...serializeSettings(nodeSettings, {} as NodeStaticResults, /* isTrigger */ false),
    },
    triggerInputs,
  };
};

const getTriggerInputExpression = (input: SerializedParameter): string => {
  return input.type === 'string' ? `@{triggerBody()?['${input.parameterName}']}` : `@triggerBody()?['${input.parameterName}']`;
};

const generateDefinition = (
  operationName: string,
  operationDefinition: LogicAppsV2.ActionDefinition,
  triggerInputs: SerializedParameter[]
): LogicAppsV2.WorkflowDefinition => {
  const inputsSchema = generateInputsSchema(triggerInputs);
  return {
    $schema: 'https://schema.management.azure.com/schemas/2016-06-01/workflowdefinition.json#',
    contentVersion: '1.0.0',
    actions: {
      [operationName]: operationDefinition,
      Response: {
        type: 'Response',
        inputs: {
          statusCode: 200,
          body: `@body('${operationName}')`,
        },
        runAfter: {
          [operationName]: ['Succeeded'],
        },
      },
    },
    triggers: {
      Request: {
        type: 'Request',
        kind: 'Http',
        inputs: {
          schema: inputsSchema,
        },
        description: '<Pending>This trigger is automatically generated by the MCP serializer.',
      },
    },
  };
};

const generateInputsSchema = (inputs: SerializedParameter[]): any => {
  const required: string[] = [];
  const properties = inputs.reduce((result: Record<string, any>, input) => {
    result[input.parameterName] = input.schema; // TODO: If we need to update anything in the schema.

    if (input.required) {
      required.push(input.parameterName);
    }

    return result;
  }, {});

  return {
    type: 'object',
    required,
    properties,
  };
};
