import Constants from '../../common/constants';
import type { NodeDataWithManifest } from '../actions/bjsworkflow/operationdeserializer';
import type { Settings } from '../actions/bjsworkflow/settings';
import type { WorkflowNode } from '../parsers/models/workflowNode';
import type { OutputInfo } from '../state/operation/operationMetadataSlice';
import type { TokensState } from '../state/tokensSlice';
import type { NodesMetadata } from '../state/workflow/workflowInterfaces';
import { getAllNodesInsideNode, getUpstreamNodeIds } from './graph';
import { getRepetitionContext, getTokenExpressionValue, shouldIncludeSelfForRepetitionReference } from './parameters/helper';
import { hasSecureOutputs } from './setting';
import { getVariableTokens } from './variables';
import { getIntl } from '@microsoft-logic-apps/intl';
import { OutputKeys, parseEx } from '@microsoft-logic-apps/parsers';
import type { BuiltInOutput, OperationManifest } from '@microsoft-logic-apps/utils';
import type { FunctionDefinition, OutputToken } from '@microsoft/designer-ui';
import { TemplateFunctions, TokenType } from '@microsoft/designer-ui';

const FxIcon =
  'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAzNCAzNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCiA8cmVjdCB3aWR0aD0iMzQiIGhlaWdodD0iMzQiIGZpbGw9IiNhZDAwOGMiLz4NCiA8cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNMTMuNDg3LDEzLjI0OGE3LjA1NCw3LjA1NCwwLDAsMSwxLjg0OS0zLjY5QTUuMyw1LjMsMCwwLDEsMTguNTkzLDcuOWMuOTg1LDAsMS40NjcuNTg1LDEuNDQ3LDEuMDY5YTEuNTUxLDEuNTUxLDAsMCwxLS43NDQsMS4xNDkuNDA2LjQwNiwwLDAsMS0uNTQzLS4wNjFjLS41NDMtLjY2NS0xLjAwNS0xLjA2OS0xLjM2Ny0xLjA2OS0uNC0uMDItLjc2NC4yODItMS40MDcsNC4yNTVoMi4zMzJsLS40MjIuODA3LTIuMDkuMTYxYy0uMzQyLDEuODM1LS42LDMuNjMtMS4xNDYsNS45MDgtLjc4NCwzLjMyNy0xLjY4OCw0LjY1OC0zLjEsNS44MjdBMy43NDYsMy43NDYsMCwwLDEsOS4zNDcsMjdDOC42ODMsMjcsOCwyNi41NTYsOCwyNi4wMzJhMS42OTIsMS42OTIsMCwwLDEsLjcyNC0xLjE0OWMuMTYxLS4xMjEuMjgxLS4xNDEuNDIyLS4wNGEyLjg3MywyLjg3MywwLDAsMCwxLjU2OC43MDYuNjc1LjY3NSwwLDAsMCwuNjYzLS41LDI3LjQyNywyNy40MjcsMCwwLDAsLjg0NC00LjE3NGMuNDYyLTIuNzYyLjc0NC00LjY1OCwxLjA4NS02LjY1NEgxMS43bC0uMS0uMi42ODMtLjc2NloiLz4NCiA8cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNMTcuMzIxLDE4LjljLjgxMi0xLjE4MywxLjY1NC0xLjg3NCwyLjIzNi0xLjg3NC40OSwwLC43MzUuNTIyLDEuMDU3LDEuNDlsLjIzLjcyMmMxLjE2NC0xLjY3NSwxLjczMS0yLjIxMiwyLjQtMi4yMTJhLjc0Mi43NDIsMCwwLDEsLjc1MS44NDUuOTIyLjkyMiwwLDAsMS0uOC44NzYuNDE0LjQxNCwwLDAsMS0uMjkxLS4xNjkuNDc3LjQ3NywwLDAsMC0uMzY4LS4xODRjLS4xNTMsMC0uMzM3LjEwOC0uNjEzLjM4NGE4LjU0Nyw4LjU0NywwLDAsMC0uODczLDEuMDc1bC42MTMsMS45NjZjLjE4NC42My4zNjcuOTUyLjU2Ny45NTIuMTg0LDAsLjUwNi0uMjQ2LDEuMDQyLS44OTFsLjMyMi4zODRjLS45LDEuNDI5LTEuNzYxLDEuOTItMi4zNDMsMS45Mi0uNTIxLDAtLjg1OC0uNDMtMS4xOC0xLjQ5bC0uMzUyLTEuMTY4Yy0xLjE3OSwxLjkyLTEuNzQ2LDIuNjU4LTIuNTQzLDIuNjU4YS44MTUuODE1LDAsMCwxLS44MTItLjg3NS45LjksMCwwLDEsLjc2Ni0uOTIyLjQ5My40OTMsMCwwLDEsLjI5MS4xNTQuNTE0LjUxNCwwLDAsMCwuMzY4LjE2OWMuMzM3LDAsLjk1LS42NzYsMS43MTUtMS44NTlsLS40LTEuMzY3Yy0uMjc2LS45MDYtLjQxNC0xLjAxNC0uNTY3LTEuMDE0LS4xMzgsMC0uNDE0LjItLjg4OC44MTRaIi8+DQo8L3N2Zz4NCg==';
export interface TokenGroup {
  id: string;
  label: string;
  tokens: OutputToken[];
  hasAdvanced?: boolean;
  showAdvanced?: boolean;
}

export function getTokenNodeIds(
  nodeId: string,
  graph: WorkflowNode,
  nodesMetadata: NodesMetadata,
  nodesManifest: Record<string, NodeDataWithManifest>,
  operationMap: Record<string, string>
): string[] {
  const manifest = nodesManifest[nodeId]?.manifest;
  const tokenNodes = getUpstreamNodeIds(nodeId, graph, nodesMetadata, operationMap);

  // Should include itself as repetition reference if nodes can reference its outputs
  // generated by its inputs like Query, Select and Table operations.
  const includeSelf = shouldIncludeSelfForRepetitionReference(manifest);
  const repetitionContext = getRepetitionContext(includeSelf);

  if (repetitionContext && repetitionContext.repetitionReferences) {
    for (const repetitionReference of repetitionContext.repetitionReferences) {
      const { actionName } = repetitionReference;
      const nodeManifest = nodesManifest[actionName]?.manifest;
      // If repetition is set for a node but not set for self reference,
      // then nodes having this type as repetition can reference its outputs like Foreach and Until
      if (nodeManifest?.properties.repetition && !nodeManifest.properties.repetition.self) {
        tokenNodes.push(actionName);
      }
    }
  }

  if (manifest?.properties?.outputTokens?.selfReference) {
    const allNodesInsideNode = getAllNodesInsideNode(nodeId, graph, operationMap);
    tokenNodes.push(...allNodesInsideNode);
  }

  return tokenNodes;
}

export function getBuiltInTokens(manifest: OperationManifest): OutputToken[] {
  if (!manifest) {
    return [];
  }

  const icon = manifest.properties.iconUri;
  const brandColor = manifest.properties.brandColor;

  return (manifest.properties.outputTokens?.builtIns || []).map(({ name, title, required, type }: BuiltInOutput) => ({
    key: `system.$.function.${name}`,
    brandColor,
    icon,
    title,
    name,
    type,
    isAdvanced: false,
    outputInfo: {
      type: TokenType.OUTPUTS,
      required,
    },
  }));
}

export function convertOutputsToTokens(
  nodeId: string,
  nodeType: string,
  outputs: Record<string, OutputInfo>,
  manifest: OperationManifest,
  settings?: Settings
): OutputToken[] {
  if (!manifest) {
    return [];
  }

  const icon = manifest.properties.iconUri;
  const brandColor = manifest.properties.brandColor;
  const isSecure = hasSecureOutputs(nodeType, settings);

  // TODO - Look at repetition context to get foreach context correctly in tokens and for splitOn

  return Object.keys(outputs).map((outputKey) => {
    const { key, name, type, isAdvanced, required, format, source, isInsideArray, parentArray, itemSchema, value } = outputs[outputKey];
    return {
      key,
      brandColor,
      icon,
      title: getTokenTitle(outputs[outputKey]),
      name,
      type,
      value,
      isAdvanced,
      outputInfo: {
        type: TokenType.OUTPUTS,
        required,
        format,
        source,
        isSecure,
        actionName: nodeId,
        arrayDetails: isInsideArray ? { itemSchema, parentArray } : undefined,
      },
    };
  });
}

export function getExpressionTokenSections(): TokenGroup[] {
  return TemplateFunctions.map((functionGroup) => {
    const { id, name, functions } = functionGroup;
    const hasAdvanced = functions.some((func) => func.isAdvanced);
    const tokens = functions.map(({ name, defaultSignature, description, isAdvanced }: FunctionDefinition) => ({
      key: name,
      brandColor: '#AD008C',
      icon: FxIcon,
      title: defaultSignature,
      name,
      type: Constants.SWAGGER.TYPE.ANY,
      description,
      isAdvanced,
      outputInfo: {
        type: TokenType.FX,
        functionName: name,
      },
    }));

    return {
      id,
      label: name,
      hasAdvanced,
      showAdvanced: false,
      tokens,
    };
  });
}

export function getOutputTokenSections(state: TokensState, nodeId: string): TokenGroup[] {
  const { variables, outputTokens } = state;
  const nodeTokens = outputTokens[nodeId];
  if (!nodeTokens) return [];
  const variableTokenGroup = {
    id: 'variables',
    label: getIntl().formatMessage({ description: 'Heading section for Variable tokens', defaultMessage: 'Variables' }),
    tokens: getVariableTokens(variables, nodeTokens),
  };

  const outputTokenGroups = nodeTokens.upstreamNodeIds.map((upstreamNodeId) => {
    let tokens = outputTokens[upstreamNodeId].tokens;
    tokens = tokens.map((token) => {
      return { ...token, value: getTokenExpressionValue({ ...token, tokenType: TokenType.OUTPUTS }) };
    });

    if (!tokens.length) {
      return undefined;
    }

    return {
      id: upstreamNodeId,
      label: upstreamNodeId, // TODO: get friendly name for this node.
      tokens,
      hasAdvanced: tokens.some((token) => token.isAdvanced),
      showAdvanced: false,
    };
  });

  return [variableTokenGroup, ...(outputTokenGroups.filter((group) => !!group) as TokenGroup[])];
}

function getTokenTitle(output: OutputInfo): string {
  if (output.title) {
    return output.title;
  }

  if (output.isInsideArray) {
    return output.parentArray ? `${output.parentArray} - Item` : 'Item';
  }

  if (output.name) {
    switch (output.name) {
      case OutputKeys.Item:
        return 'Item';
      case OutputKeys.PathParameters:
        return 'Path Parameters';
      default:
        // eslint-disable-next-line no-case-declarations
        const segments = parseEx(output.name);
        return String(segments[segments.length - 1].value);
    }
  }

  return 'Body';
}
