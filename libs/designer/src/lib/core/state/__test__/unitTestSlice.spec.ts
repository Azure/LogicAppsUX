import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import unitTestReducer, {
  addAssertion,
  deleteAssertion,
  updateAssertion,
  updateAssertionExpression,
  initUnitTestDefinition,
  updateMockSuccess,
  updateMockFailure,
  updateActionResultSuccess,
  updateActionResultFailure,
  initialUnitTestState,
} from '../unitTest/unitTestSlice';
import { resetWorkflowState } from '../global';
import type {
  UnitTestState,
  InitDefintionPayload,
  AddAssertionPayload,
  DeleteAssertionsPayload,
  UpdateAssertionPayload,
  UpdateAssertioExpressionPayload,
  updateMockPayload,
  updateMockResultPayload,
  OutputMock,
} from '../unitTest/unitTestInterfaces';
import type { Assertion, AssertionDefinition, ValueSegment } from '@microsoft/logic-apps-shared';

// Mock the intl module
vi.mock('@microsoft/logic-apps-shared', async () => {
  const actual = await vi.importActual('@microsoft/logic-apps-shared');
  let guidCounter = 0;
  return {
    ...actual,
    getIntl: vi.fn(() => ({
      formatMessage: vi.fn(({ defaultMessage }) => defaultMessage),
    })),
    guid: vi.fn(() => `test-guid-${++guidCounter}`),
  };
});

// Mock the workflowparameters validation
vi.mock('../workflowparameters/workflowparametersSlice', () => ({
  validateParameter: vi.fn(() => undefined), // Return no validation error by default
}));

describe('unitTestSlice', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('initial state', () => {
    it('should return the initial state', () => {
      expect(unitTestReducer(undefined, { type: 'unknown' })).toEqual(initialUnitTestState);
    });

    it('should have correct initial state structure', () => {
      expect(initialUnitTestState).toEqual({
        mockResults: {},
        assertions: {},
        validationErrors: {
          assertions: {},
          mocks: {},
        },
      });
    });
  });

  describe('initUnitTestDefinition', () => {
    it('should initialize with empty payload', () => {
      const result = unitTestReducer(initialUnitTestState, initUnitTestDefinition(null));
      expect(result).toEqual(initialUnitTestState);
    });

    it('should initialize with assertions and mock results', () => {
      const mockAssertions: Assertion[] = [
        {
          name: 'Test Assertion 1',
          description: 'First test assertion',
          assertionString: 'equals(outputs("action1"), "expected")',
        },
        {
          name: 'Test Assertion 2',
          description: 'Second test assertion',
          assertionString: 'greater(outputs("action2"), 0)',
        },
      ];

      const mockResults: Record<string, OutputMock> = {
        action1: {
          output: {
            body: [{ id: '1', type: 'literal', value: 'test output' }],
          },
          actionResult: 'success',
          isCompleted: true,
        },
      };

      const payload: InitDefintionPayload = {
        assertions: mockAssertions,
        mockResults,
      };

      const result = unitTestReducer(initialUnitTestState, initUnitTestDefinition(payload));

      expect(result.mockResults).toEqual(mockResults);
      expect(Object.keys(result.assertions)).toHaveLength(2);
      
      // Get the actual keys generated by the GUID function
      const actualKeys = Object.keys(result.assertions);
      
      expect(result.assertions[actualKeys[0]]).toEqual({
        id: actualKeys[0],
        name: 'Test Assertion 1',
        description: 'First test assertion',
        assertionString: 'equals(outputs("action1"), "expected")',
        isEditable: false,
      });
      expect(result.assertions[actualKeys[1]]).toEqual({
        id: actualKeys[1],
        name: 'Test Assertion 2',
        description: 'Second test assertion',
        assertionString: 'greater(outputs("action2"), 0)',
        isEditable: false,
      });
    });

    it('should handle undefined payload', () => {
      const result = unitTestReducer(initialUnitTestState, initUnitTestDefinition(undefined as any));
      expect(result).toEqual(initialUnitTestState);
    });
  });

  describe('addAssertion', () => {
    it('should add a new assertion', () => {
      const assertion: AssertionDefinition = {
        id: 'assertion-1',
        name: 'New Assertion',
        description: 'Test description',
        assertionString: 'equals(1, 1)',
        isEditable: true,
      };

      const payload: AddAssertionPayload = { assertion };
      const result = unitTestReducer(initialUnitTestState, addAssertion(payload));

      expect(result.assertions['assertion-1']).toEqual(assertion);
    });

    it('should add assertion to existing state', () => {
      const existingState: UnitTestState = {
        ...initialUnitTestState,
        assertions: {
          'existing-1': {
            id: 'existing-1',
            name: 'Existing Assertion',
            description: 'Already there',
            assertionString: 'true',
            isEditable: false,
          },
        },
      };

      const newAssertion: AssertionDefinition = {
        id: 'assertion-2',
        name: 'Second Assertion',
        description: 'Another test',
        assertionString: 'false',
        isEditable: true,
      };

      const result = unitTestReducer(existingState, addAssertion({ assertion: newAssertion }));

      expect(Object.keys(result.assertions)).toHaveLength(2);
      expect(result.assertions['existing-1']).toBeDefined();
      expect(result.assertions['assertion-2']).toEqual(newAssertion);
    });
  });

  describe('deleteAssertion', () => {
    it('should delete an existing assertion', () => {
      const existingState: UnitTestState = {
        ...initialUnitTestState,
        assertions: {
          'assertion-1': {
            id: 'assertion-1',
            name: 'To Delete',
            description: 'Will be removed',
            assertionString: 'true',
            isEditable: true,
          },
          'assertion-2': {
            id: 'assertion-2',
            name: 'To Keep',
            description: 'Will remain',
            assertionString: 'false',
            isEditable: true,
          },
        },
        validationErrors: {
          assertions: {
            'assertion-1': { name: 'Some error' },
          },
          mocks: {},
        },
      };

      const payload: DeleteAssertionsPayload = { assertionId: 'assertion-1' };
      const result = unitTestReducer(existingState, deleteAssertion(payload));

      expect(result.assertions['assertion-1']).toBeUndefined();
      expect(result.assertions['assertion-2']).toBeDefined();
      expect(result.validationErrors.assertions['assertion-1']).toBeUndefined();
    });

    it('should handle deleting non-existent assertion', () => {
      const result = unitTestReducer(
        initialUnitTestState,
        deleteAssertion({ assertionId: 'non-existent' })
      );
      expect(result).toEqual(initialUnitTestState);
    });
  });

  describe('updateAssertion', () => {
    it('should update an existing assertion', () => {
      const existingState: UnitTestState = {
        ...initialUnitTestState,
        assertions: {
          'assertion-1': {
            id: 'assertion-1',
            name: 'Original Name',
            description: 'Original Description',
            assertionString: 'original expression',
            isEditable: false,
          },
        },
      };

      const updatedAssertion: AssertionDefinition = {
        id: 'assertion-1',
        name: 'Updated Name',
        description: 'Updated Description',
        assertionString: 'updated expression',
        isEditable: true,
      };

      const payload: UpdateAssertionPayload = { assertionToUpdate: updatedAssertion };
      const result = unitTestReducer(existingState, updateAssertion(payload));

      expect(result.assertions['assertion-1']).toEqual(updatedAssertion);
    });

    it('should preserve other assertions when updating one', () => {
      const existingState: UnitTestState = {
        ...initialUnitTestState,
        assertions: {
          'assertion-1': {
            id: 'assertion-1',
            name: 'First',
            description: 'First assertion',
            assertionString: 'true',
            isEditable: false,
          },
          'assertion-2': {
            id: 'assertion-2',
            name: 'Second',
            description: 'Second assertion',
            assertionString: 'false',
            isEditable: false,
          },
        },
      };

      const updatedAssertion: AssertionDefinition = {
        id: 'assertion-1',
        name: 'Updated First',
        description: 'Updated first assertion',
        assertionString: 'maybe true',
        isEditable: true,
      };

      const result = unitTestReducer(existingState, updateAssertion({ assertionToUpdate: updatedAssertion }));

      expect(result.assertions['assertion-1']).toEqual(updatedAssertion);
      expect(result.assertions['assertion-2']).toEqual(existingState.assertions['assertion-2']);
    });
  });

  describe('updateAssertionExpression', () => {
    it('should update only the assertion string', () => {
      const existingState: UnitTestState = {
        ...initialUnitTestState,
        assertions: {
          'assertion-1': {
            id: 'assertion-1',
            name: 'Test Assertion',
            description: 'Test Description',
            assertionString: 'old expression',
            isEditable: true,
          },
        },
      };

      const payload: UpdateAssertioExpressionPayload = {
        id: 'assertion-1',
        assertionString: 'new expression',
      };

      const result = unitTestReducer(existingState, updateAssertionExpression(payload));

      expect(result.assertions['assertion-1']).toEqual({
        id: 'assertion-1',
        name: 'Test Assertion',
        description: 'Test Description',
        assertionString: 'new expression',
        isEditable: true,
      });
    });
  });

  describe('updateMockSuccess', () => {
    it('should update mock results with success output', () => {
      const outputs: ValueSegment[] = [
        { id: '1', type: 'literal', value: 'success output' },
      ];

      const payload: updateMockPayload = {
        operationName: 'action1',
        outputs,
        outputId: 'body',
        completed: true,
        type: 'string',
      };

      const result = unitTestReducer(initialUnitTestState, updateMockSuccess(payload));

      expect(result.mockResults['action1']).toEqual({
        output: {
          body: outputs,
        },
        isCompleted: true,
      });
    });

    it('should add to existing operation outputs', () => {
      const existingState: UnitTestState = {
        ...initialUnitTestState,
        mockResults: {
          action1: {
            output: {
              body: [{ id: '1', type: 'literal', value: 'existing' }],
            },
            actionResult: 'success',
            isCompleted: false,
          },
        },
      };

      const newOutputs: ValueSegment[] = [
        { id: '2', type: 'literal', value: 'headers output' },
      ];

      const payload: updateMockPayload = {
        operationName: 'action1',
        outputs: newOutputs,
        outputId: 'headers',
        completed: true,
        type: 'object',
      };

      const result = unitTestReducer(existingState, updateMockSuccess(payload));

      expect(result.mockResults['action1'].output).toEqual({
        body: [{ id: '1', type: 'literal', value: 'existing' }],
        headers: newOutputs,
      });
      expect(result.mockResults['action1'].isCompleted).toBe(true);
    });
  });

  describe('updateMockFailure', () => {
    it('should update mock results with failure output', () => {
      const outputs: ValueSegment[] = [
        { id: '1', type: 'literal', value: 'error output' },
      ];

      const payload: updateMockPayload = {
        operationName: 'action1',
        outputs,
        outputId: 'body',
        completed: true,
        type: 'string',
        errorMessage: 'Operation failed',
        errorCode: '500',
      };

      const result = unitTestReducer(initialUnitTestState, updateMockFailure(payload));

      expect(result.mockResults['action1']).toEqual({
        output: {
          body: outputs,
        },
        isCompleted: true,
        errorMessage: 'Operation failed',
        errorCode: '500',
      });
    });

    it('should preserve existing outputs when adding failure', () => {
      const existingState: UnitTestState = {
        ...initialUnitTestState,
        mockResults: {
          action1: {
            output: {
              body: [{ id: '1', type: 'literal', value: 'existing' }],
            },
            actionResult: 'success',
          },
        },
      };

      const failureOutputs: ValueSegment[] = [
        { id: '2', type: 'literal', value: 'error details' },
      ];

      const payload: updateMockPayload = {
        operationName: 'action1',
        outputs: failureOutputs,
        outputId: 'error',
        completed: false,
        type: 'object',
        errorMessage: 'Validation failed',
        errorCode: '400',
      };

      const result = unitTestReducer(existingState, updateMockFailure(payload));

      expect(result.mockResults['action1'].output).toEqual({
        body: [{ id: '1', type: 'literal', value: 'existing' }],
        error: failureOutputs,
      });
      expect(result.mockResults['action1'].errorMessage).toBe('Validation failed');
      expect(result.mockResults['action1'].errorCode).toBe('400');
    });
  });

  describe('updateActionResultSuccess', () => {
    it('should update action result with success and clear errors', () => {
      const existingState: UnitTestState = {
        ...initialUnitTestState,
        mockResults: {
          action1: {
            output: {},
            actionResult: 'pending',
            errorMessage: 'Previous error',
            errorCode: '500',
          },
        },
      };

      const payload: updateMockResultPayload = {
        operationName: 'action1',
        actionResult: 'success',
        completed: true,
      };

      const result = unitTestReducer(existingState, updateActionResultSuccess(payload));

      expect(result.mockResults['action1']).toEqual({
        output: {},
        actionResult: 'success',
        isCompleted: true,
        errorMessage: undefined,
        errorCode: undefined,
      });
    });
  });

  describe('updateActionResultFailure', () => {
    it('should update action result with failure and set errors', () => {
      const existingState: UnitTestState = {
        ...initialUnitTestState,
        mockResults: {
          action1: {
            output: {},
            actionResult: 'pending',
          },
        },
      };

      const payload: updateMockResultPayload = {
        operationName: 'action1',
        actionResult: 'failed',
        completed: true,
        errorMessage: 'Action execution failed',
        errorCode: 'ExecutionError',
      };

      const result = unitTestReducer(existingState, updateActionResultFailure(payload));

      expect(result.mockResults['action1']).toEqual({
        output: {},
        actionResult: 'failed',
        isCompleted: true,
        errorMessage: 'Action execution failed',
        errorCode: 'ExecutionError',
      });
    });
  });

  describe('resetWorkflowState integration', () => {
    it('should reset to initial state when resetWorkflowState is dispatched', () => {
      const stateWithData: UnitTestState = {
        mockResults: {
          action1: {
            output: { body: [{ id: '1', type: 'literal', value: 'test' }] },
            actionResult: 'success',
            isCompleted: true,
          },
        },
        assertions: {
          'assertion-1': {
            id: 'assertion-1',
            name: 'Test',
            description: 'Test assertion',
            assertionString: 'true',
            isEditable: true,
          },
        },
        validationErrors: {
          assertions: {
            'assertion-1': { name: 'Error' },
          },
          mocks: {
            'action1-body': { value: 'Mock error' },
          },
        },
      };

      const result = unitTestReducer(stateWithData, resetWorkflowState());

      expect(result).toEqual(initialUnitTestState);
    });
  });

  describe('validation error handling', () => {
    it('should handle validation errors in mock updates', async () => {
      const { validateParameter } = await import('../workflowparameters/workflowparametersSlice');
      vi.mocked(validateParameter).mockReturnValue('Validation error message');

      const outputs: ValueSegment[] = [
        { id: '1', type: 'literal', value: 'invalid value' },
      ];

      const payload: updateMockPayload = {
        operationName: 'action1',
        outputs,
        outputId: 'body',
        completed: true,
        type: 'number', // Type mismatch with string value
      };

      const result = unitTestReducer(initialUnitTestState, updateMockSuccess(payload));

      expect(result.validationErrors.mocks['action1-body']).toEqual({
        value: 'Validation error message',
      });
    });

    it('should clear validation errors when validation passes', async () => {
      const existingState: UnitTestState = {
        ...initialUnitTestState,
        validationErrors: {
          assertions: {},
          mocks: {
            'action1-body': { value: 'Previous error' },
          },
        },
      };

      // Mock validation to return no error
      const { validateParameter } = await import('../workflowparameters/workflowparametersSlice');
      vi.mocked(validateParameter).mockReturnValue(undefined);

      const outputs: ValueSegment[] = [
        { id: '1', type: 'literal', value: '123' },
      ];

      const payload: updateMockPayload = {
        operationName: 'action1',
        outputs,
        outputId: 'body',
        completed: true,
        type: 'number',
      };

      const result = unitTestReducer(existingState, updateMockSuccess(payload));

      expect(result.validationErrors.mocks['action1-body']).toBeUndefined();
    });
  });

  describe('edge cases', () => {
    it('should handle empty outputs array', () => {
      const payload: updateMockPayload = {
        operationName: 'action1',
        outputs: [],
        outputId: 'body',
        completed: true,
        type: 'string',
      };

      const result = unitTestReducer(initialUnitTestState, updateMockSuccess(payload));

      expect(result.mockResults['action1'].output.body).toEqual([]);
    });

    it('should handle operations with no existing mock results', () => {
      const payload: updateMockResultPayload = {
        operationName: 'newAction',
        actionResult: 'success',
        completed: true,
      };

      const result = unitTestReducer(initialUnitTestState, updateActionResultSuccess(payload));

      expect(result.mockResults['newAction']).toEqual({
        actionResult: 'success',
        isCompleted: true,
        errorMessage: undefined,
        errorCode: undefined,
      });
    });

    it('should handle updating assertion that does not exist', () => {
      const payload: UpdateAssertioExpressionPayload = {
        id: 'non-existent',
        assertionString: 'new expression',
      };

      const result = unitTestReducer(initialUnitTestState, updateAssertionExpression(payload));

      // Should create a new assertion with undefined values for missing properties
      expect(result.assertions['non-existent']).toEqual({
        assertionString: 'new expression',
      });
    });
  });
});
