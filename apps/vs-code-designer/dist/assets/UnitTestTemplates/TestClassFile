namespace <%= LogicAppName %>.Tests
{
    using Microsoft.Azure.Workflows.UnitTesting;
    using Microsoft.Azure.Workflows.UnitTesting.Definitions;
    using Newtonsoft.Json.Linq;
    using Microsoft.VisualStudio.TestTools.UnitTesting;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Threading.Tasks;

    /// <summary>
    /// The unit test class for testing the workflow named <%= WorkflowName %>.
    /// This class is automatically generated when you choose to create a unit test from a workflow run in Visual Studio Code.
    /// You can edit this class to modify the test, mock data, and assertions as necessary.
    /// </summary>
    [TestClass]
    public class <%= UnitTestName %>
    {
        /// <summary>
        /// The relative path to workflow JSON file.
        /// </summary>
        private string workflowDefinitionPath;

        /// <summary>
        /// The relative path to connections JSON file.
        /// </summary>
        private string connectionsPath;

        /// <summary>
        /// The relative path to parameters JSON file.
        /// </summary>
        private string parametersPath;

        /// <summary>
        /// The relative path to local settings JSON file.
        /// </summary>
        private string localSettingsPath;

        /// <summary>
        /// The mocked trigger outputs that are generated from a workflow run.
        /// </summary>
        public TriggerMock triggerMock;

        /// <summary>
        /// The mocked data for the actions generated from a workflow run.
        /// </summary>
        public Dictionary<string, ActionMock> actionMocks;

        /// <summary>
        /// Initializes a new instance of the class named <see cref="<%= UnitTestName %>" />.
        /// This constructor loads the necessary paths for the workflow, connections, parameters, and local settings JSON files.
        /// The constructor also loads the mock data from the file named <%= UnitTestName %>-mock.json.
        /// </summary>
        public <%= UnitTestName %>()
        {
            this.workflowDefinitionPath = @"../<%= logicAppName %>/<%= workflowName %>/workflow.json";
            this.connectionsPath = @"../<%= logicAppName %>/connections.json";
            this.parametersPath = @"../<%= logicAppName %>/parameters.json";
            this.localSettingsPath = @"../<%= logicAppName %>/local.settings.json";

            // Load the mock data from the file named <%= UnitTestName %>-mock.json.
            var mockData = JObject.Parse(File.ReadAllText(@"<%= UnitTestName %>-mock.json"));
            this.triggerMock = mockData["triggerMocks"].ToObject<Dictionary<string, TriggerMock>>().FirstOrDefault().Value;
            this.actionMocks = mockData["actionMocks"].ToObject<Dictionary<string, ActionMock>>();
        }

        /// <summary>
        /// A sample unit test for executing the workflow named <%= WorkflowName %>.
        /// This method shows how to set up mock data, execute the workflow, and assert the outcome.
        /// </summary>
        [TestMethod]
        public async Task <%= WorkflowName %>_<%= UnitTestName %>_ExecuteWorkflow_SUCCESS()
        {
            // PREPARE Mock
            // Set up mock data for the action named '<actionName>'.
            var actionMocks = this.actionMocks;
            actionMocks["<actionName>"] = new ActionMock(
                "<actionName>", 
                TestWorkflowStatus.Succeeded, 
                onGetActionOutputsCallback: this.Mock<actionName>OutputCallback
            );

            // ACT 
            // Create an instance of UnitTestExecutor, and run the workflow with the mock data.
            var executor = new UnitTestExecutor(this.workflowDefinitionPath, this.connectionsPath, this.parametersPath, this.localSettingsPath);
            var testRun = await executor.RunWorkflowAsync(this.triggerMock, actionMocks).ConfigureAwait(false);

            // ASSERT
            // Verify that the workflow executed successfully, and the status is 'Succeeded'.
            Assert.IsNotNull(testRun);
            Assert.AreEqual(TestWorkflowStatus.Succeeded, testRun.Status);
        }

        #region Mock generator helpers

        /// <summary>
        /// The callback method to dynamically generate mocked data for the action named '<actionName>'.
        /// You can modify this method to return different mock outputs based on the test scenario.
        /// </summary>
        /// <param name="context">The test execution context that contains information about the current test run.</param>
        public JToken Mock<actionName>OutputCallback(TestExecutionContext context)
        {
            // Sample mock data 1: Replace <your-test-JSON-value> with the appropriate mock data for the test.
            // return JObject.Parse(@"
            // {
            //     'statusCode': '200',
            //     'body': {
            //         <your-test-JSON value>
            //     }
            // }");

            // Sample mock data 2: Modify the existing mocked data dynamically for <actionName>.
            // var mockDataToModify = this.actionMocks["<actionName>"];
            // mockDataToModify.Outputs["body"]["<property1Name>"] = "<your-test-string-value>";
            // return mockDataToModify.Outputs;
        }

        #endregion
    }
}